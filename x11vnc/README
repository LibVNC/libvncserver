
x11vnc README file                         Date: Tue Jun 21 09:58:37 EDT 2005

The following information is taken from these URLs:

	http://www.karlrunge.com/x11vnc/index.html
	http://www.karlrunge.com/x11vnc/x11vnc_opts.html

they contain the most up to date info.

=======================================================================
http://www.karlrunge.com/x11vnc/index.html:

     _________________________________________________________________

x11vnc: a VNC server for real X displays
                (to [1]FAQ)    (to [2]Downloads)    (to [3]Building)    (to
[4]Donations)    (to [5]Beta Test)

   x11vnc allows one to remotely view and interact with real X displays
   (i.e. a display corresponding to a physical monitor, keyboard, and
   mouse) with any VNC viewer. In this way it plays the role for Unix/X11
   that WinVNC plays for Windows.

   I wrote x11vnc because x0rfbserver was basically impossible to build
   on Solaris and had poor performance. The primary x0rfbserver build
   problems centered around esoteric C++ toolkits. x11vnc is written in
   plain C and uses only standard libraries. I also added a few
   enhancements to improve the interactive response, add esoteric
   features, etc. The [6]FAQ contains a lot of information and solutions
   to problems, but please feel free to [7]contact me if you have
   problems or questions.

    Background:

   VNC (Virtual Network Computing) is a very useful network graphics
   protocol (applications running on one computer but displaying their
   windows on another) in the spirit of X, however, unlike X, the
   viewing-end is very simple and maintains no state. It is a remote
   framebuffer (RFB) protocol

   Some VNC links:
     * [8]http://www.uk.research.att.com/vnc/
     * [9]http://www.realvnc.com
     * [10]http://www.tightvnc.com

   For Unix, the VNC implementation includes a virtual X11 server Xvnc
   (usually launched via the vncserver command) that is not associated
   with a physical display, but provides a "fake" one X11 clients (xterm,
   mozilla, etc.) can attach to. A remote user then connects to Xvnc via
   the VNC client vncviewer from anywhere on the network to view and
   interact with the whole virtual X11 desktop.

   The VNC protocol is in most cases better suited for remote connections
   with low bandwidth and high latency than is the X11 protocol (the
   exception is cached pixmap data on the viewing-end). Also, with no
   state maintained the viewing-end can crash, be rebooted, or relocated
   and the applications and desktop continue running. Not so with X11.

   So the standard Xvnc/vncserver program is very useful, I use it for
   things like:
     * Desktop conferencing with other users (e.g. codereviews).
     * Long running apps/tasks I want to be able to view from many
       places.
     * Motif, GNOME, and similar applications that would yield very poor
       performance over a high latency link.

   However, sometimes one wants to connect to a real X11 display (i.e.
   one attached to a physical monitor, keyboard, and mouse: a Workstation
   or a SunRay session) from far away. Maybe you want to close down an
   application cleanly rather than using kill, or want to work a bit in
   an already running application, or would like to help a distant
   colleague solve a problem with their desktop. This is where x11vnc is
   useful.
     _________________________________________________________________

    How to use x11vnc:

   In this basic example let's assume the remote machine with the X
   display you wish to view is "far-away.east:0" and the workstation you
   are presently working at is "sitting-here.west".

   Step 0. Download x11vnc ([11]see below) and have it available to run
   on far-away.east. Similarly, have a VNC viewer (e.g. vncviewer) ready
   to run on sitting-here.west. We recommend [12]TightVNC Viewers.

   Step 1. By some means log in to far-away.east and get a command shell
   running there. You can use ssh, rlogin, telnet, or any other method to
   do this. x11vnc needs to be run on the same machine the X server
   process is running on (otherwise things would be extremely slow).

   Step 2. In that far-away.east shell (with command prompt "far-away>"
   in this example) run x11vnc directed at the far-away.east X session
   display:

  far-away> x11vnc -display :0

   You could have also set the environment variable DISPLAY=:0 instead of
   using -display. This step attaches x11vnc to the far-away.east:0 X
   display (i.e. no viewer clients yet).

   To get X11 permissions right, you may also need to set the XAUTHORITY
   environment variable (or use the [13]-auth option) to point to the
   correct MIT-MAGIC-COOKIE file (e.g. /home/joe/.Xauthority). More on
   this [14]below.

   If you suspect an X11 permissions problem do this simple test: while
   sitting at the physical X display open a terminal window
   (gnome-terminal, xterm, etc). You should be able to start x11vnc
   without any need for command line options in that terminal. If that
   works OK then you know X11 permissions are the only thing preventing
   it from working when you try to start x11vnc via a remote shell.

   When x11vnc starts up there will then be much chatter printed out,
   until it finally says something like:
  .
  .
  13/05/2004 14:59:54 Autoprobing selected port 5900
  13/05/2004 14:59:54 screen setup finished.
  13/05/2004 14:59:54 The VNC desktop is far-away:0
  PORT=5900

   which means all is OK, and we are ready for the final step.

   Step 3. At the place where you are sitting (sitting-here.west in this
   example) you now want to run a VNC viewer program. There are VNC
   viewers for Unix, Windows, MacOS, Java-enabled web browsers, and even
   for PDA's like the Palm Pilot! You can use any of them to connect to
   x11vnc (see the above VNC links under "Background:" on how to obtain a
   viewer for your platform or see [15]this FAQ. For Solaris, vncviewer
   is available in the [16]Companion CD package SFWvnc ).

   In this example we'll use the Unix vncviewer program on sitting-here
   by typing the following command in a second terminal window:

  sitting-here> vncviewer far-away.east:0

   That should pop up a viewer window on sitting-here.west showing and
   allowing interaction with the far-away.east:0  X11 desktop. Pretty
   nifty! When finished, exit the viewer: the remote x11vnc process will
   shutdown automatically (or you can use the [17]-forever option to have
   it wait for additional viewer connections).

   Shortcut: Of course if you left x11vnc running on far-away.east:0 in a
   terminal window with the [18]-forever option or as a [19]service,
   you'd only have to do Step 3 as you moved around. Be sure to use a VNC
   [20]password or [21]other measures if you do that.


   Desktop Sharing: The above more or less assumed nobody was sitting at
   the workstation display "far-away.east:0". This is often the case: a
   user wants to access her workstation remotely. Another usage pattern
   has the user sitting at "far-away.east:0" and invites one or more
   other people to view and interact with his desktop. Perhaps the user
   gives a demo or presentation this way (using the telephone for vocal
   communication). A "Remote Help Desk" mode would be similar: a
   technician remotely connects to the user's desktop to interactively
   solve a problem the user is having.

   For these cases it should be obvious how it is done. The above steps
   will work, but more easily the user sitting at far-away.east:0 simply
   starts up x11vnc from a terminal window, after which the guests would
   start their VNC viewers. For this usage mode the "[22]-connect
   host1,host2" option may be of use automatically connect to vncviewers
   in "-listen" mode on the list of hosts.
     _________________________________________________________________

    Tunnelling x11vnc via ssh:

   The above example had no security or privacy at all. When logging into
   remote machines (certainly when going over the internet) it is best to
   use ssh, or use a VPN. For x11vnc one can tunnel the VNC protocol
   through the encrypted ssh channel. It would look something like this:
  sitting-here> ssh -L 5900:localhost:5900 far-away.east 'x11vnc -display :0'

   (you will likely have to provide passwords/passphrases for the ssh
   login) and then in another terminal window on sitting-here run the
   command:
  sitting-here> vncviewer -encodings "copyrect tight zrle hextile" localhost:0

   Note: The -encodings option is very important: vncviewer will default
   to "raw" encoding if it thinks the connection is to the local machine,
   and so vncviewer gets tricked this way by the ssh redirection. "raw"
   encoding will be extremely slow over a networked link, so you need to
   force the issue with -encodings "copyrect tight ...".

   Some VNC viewers will do the ssh tunnelling for you automatically, the
   TightVNC vncviewer does this when the "-via far-away.east" option is
   supplied to it (this requires x11vnc to be already running on
   far-away.east or having it started by [23]inetd(1)). See the 3rd
   script example [24]below for more info.

   If the machine you SSH into is not the same machine with the X display
   you wish to view (e.g. your company provides incoming SSH access to a
   gateway machine), then you need to change the above to, e.g.: "-L
   5900:otherhost:5900". Once logged in, you'll need to do a second login
   (ssh, rsh, etc.) to the workstation machine 'otherhost' and then start
   up x11vnc on it (if it isn't already running). For an automatic way to
   use a gateway and have all the network traffic encrypted (including
   inside the firewall) see [25]chaining ssh's below

     _________________________________________________________________

   Scripts to automate ssh tunneling: As discussed below, there may be
   some problems with port 5900 being available. If that happens, the
   above port and display numbers may change a bit (e.g. -> 5901 and :1).
   However, if you "know" port 5900 will be free on the local and remote
   machines, you can easily automate the above two steps by using the
   x11vnc option [26]-bg (forks into background after connection to the
   display is set up) or using the -f option of ssh. Some example scripts
   are shown below.
     _________________________________________________________________

   #1. A simple example script, assuming no problems with port 5900 being
   taken on the local or remote sides, looks like:
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -rfbauth .vnc/passwd"
enc="copyrect tight zrle hextile zlib corre rre raw"

ssh -f -L 5900:localhost:5900 $host "$cmd"

for i in 1 2 3
do
        sleep 2
        if vncviewer -encodings "$enc" :0; then break; fi
done

   See also rx11vnc.pl below.
     _________________________________________________________________

   #2. Another method is to start the VNC viewer in listen mode
   "vncviewer -listen" and have x11vnc initiate a reverse connection
   using the [27]-connect option:
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -connect localhost"   # <== note new opt
ion
enc="copyrect tight zrle hextile zlib corre rre raw"

vncviewer -encodings "$enc" -listen &
pid=$!
ssh -R 5500:localhost:5500 $host "$cmd"
kill $pid

   Note the use of the ssh option -R instead of -L to set up a remote
   port redirection.
     _________________________________________________________________

   #3. A third way is specific to the TightVNC vncviewer special option
   -via for gateways. The only tricky part is we need to start up x11vnc
   and give it some time (5 seconds in this example) to start listening
   for connections (so we cannot use the TightVNC default setting for
   VNC_VIA_CMD):
#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

VNC_VIA_CMD="ssh -f -L %L:%H:%R %G x11vnc -localhost -rfbport 5900 -display :$d
isp; sleep 5"
export VNC_VIA_CMD

vncviewer -via $host localhost:0      # must be TightVNC vncviewer.

   Of course if you already have the x11vnc running waiting for
   connections (or have it started out of [28]inetd(1)), you can simply
   use the TightVNC "vncviewer -via gateway host:port" in its default
   mode to provide secure ssh tunnelling.


   VNC password file: Also note in the #1. example script that the
   [29]option "-rfbauth .vnc/passwd" provides additional protection by
   requiring a VNC password for every VNC viewer that connects. The
   vncpasswd or storepasswd programs, or the x11vnc [30]-storepasswd
   option can be used to create the password file. x11vnc also has the
   slightly less secure [31]-passwdfile and "-passwd XXXXX" [32]options
   to specify passwords.

   Important: It is up to you to tell x11vnc to use password protection,
   it will not do it for you automatically or force you to. The same goes
   for encrypting the channel between the viewer and x11vnc: it is up to
   you to use ssh, stunnel, VPN, etc. Also look into the -allow and
   -localhost [33]options and building x11vnc with [34]tcp_wrappers
   support to limit host access.


   Chaining ssh's: Note that for use of a ssh gateway and -L redirection
   to an internal host (e.g. "-L 5900:otherhost:5900") the VNC traffic
   inside the firewall is not encrypted and you have to manually log into
   otherhost to start x11vnc. Kyle Amon shows a method where you chain
   two ssh's together that encrypts all network traffic and also
   automatically starts up x11vnc on the internal workstation:
#!/bin/sh
#
gateway="example.com"   # or "user@example.com"
host="labyrinth"        # or "user@hostname"
user="kyle"

# Need to sleep long enough for all of the passwords and x11vnc to start up.
# The </dev/null below makes the vncviewer prompt for passwd via popup window.
#
(sleep 10; vncviewer -encodings "copyrect tight zrle zlib hextile" \
    localhost:0 </dev/null >/dev/null) &

# Chain the vnc connection thru 2 ssh's, and connect x11vnc to user's display:
#
exec /usr/bin/ssh -t -L 5900:localhost:5900 $gateway \
     /usr/bin/ssh -t -L 5900:localhost:5900 $host \
     sudo /usr/bin/x11vnc -localhost -auth /home/$user/.Xauthority \
         -rfbauth .vnc/passwd -display :0

   Also note the use of sudo(1) to switch to root so that the different
   user's .Xauthority file can be accessed. See the visudo(8) manpage for
   details on how to set this up. One can also chain together ssh's for
   reverse connections with vncviewers using the -listen option. For this
   case -R would replace the -L (and 5500 the 5900, see the #2 example
   script above). If the gateway machine's sshd is configured with
   GatewayPorts=no (the default) then the double chaining of "ssh -R ..."
   will be required for reverse connections to work.

     _________________________________________________________________

    Downloading x11vnc:

   x11vnc is a contributed program to the [35]LibVNCServer project at
   SourceForge.net. I use libvncserver for all of the VNC aspects; I
   couldn't have done without it. The full source code may be found and
   downloaded (either file-release tarball or CVS tree) from the above
   link. As of Feb 2005, the [36]x11vnc-0.7.1.tar.gz source package is
   released (recommended download) . The [37]x11vnc 0.7.1 release notes.

   The x11vnc package is the subset of the libvncserver package needed to
   build the x11vnc program. Also, you can get a copy of my latest,
   bleeding edge [38]x11vnc-0.7.2.tar.gz tarball.

   See the [39]FAQ below for information about where you might obtain a
   precompiled x11vnc binary from 3rd parties.

   To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix)
   try these links:
     * [40]http://www.tightvnc.com/download.html
     * [41]http://www.realvnc.com/download-free.html
     * [42]http://sourceforge.net/projects/cotvnc/


   More tools: Here is a rsh/ssh wrapper script rx11vnc that attempts to
   automatically do the above Steps 1-3 for you (provided you have
   rsh/ssh login permission on the machine x11vnc is to be run on). The
   above example would be: "rx11vnc far-away.east:0" typed into a shell
   on sitting-here.west. Also included is an experimental script
   rx11vnc.pl that attempts to tunnel the vnc traffic through an ssh port
   redirection (and does not assume port 5900 is free). Have a look at
   them to see what they do and customize as needed:
     * [43]rx11vnc wrapper script
     * [44]rx11vnc.pl wrapper script to tunnel traffic thru ssh

     _________________________________________________________________

    Building x11vnc:

   If your OS has libjpeg.so and libz.so in standard locations you can
   build as follows (example given for the 0.7.1 release of x11vnc:
   replace with the version you downloaded):
(un-tar the x11vnc+libvncserver tarball)
# gzip -dc x11vnc-0.7.1.tar.gz | tar -xvf -

(cd to the source directory)
# cd x11vnc-0.7.1

(run configure and then run make)
# ./configure
# make

(if all went OK, copy x11vnc to the desired destination, e.g. $HOME/bin)
# cp ./x11vnc/x11vnc $HOME/bin

   Or do make install, it will probably install to /usr/local/bin (run
   ./configure --help for information on customizing your configuration).
   You can now run it via typing "x11vnc", "x11vnc -help", "x11vnc -nap
   -display :0", etc.

   Note: Currently gcc is required to build libvncserver. In some cases
   it will build with non-gcc compilers, but the resulting binary often
   fails to run properly. For Solaris pre-built gcc binaries are at
   [45]http://www.sunfreeware.com/   However, one user reports it does
   work fine when built with Sun Studio 10, so YMMV.

     _________________________________________________________________

   Misc. Build problems:   We collect here rare build problems some users
   have reported and the corresponding workarounds. See also the
   [46]FAQ's on building.

   One user had a problem where the build script below was failing
   because his work environment had the ENV variable set to a script that
   was resetting his PATH so that gcc could no longer be found. Make sure
   you do not have any ENV or BASH_ENV in your environment doing things
   like that. Typing "unset ENV", etc. before configuring and building
   should clear it.

   One user had his bash shell compiled with --enable-xpg-echo-default
   that causes some strange behavior with things like echo "\\1 ..." the
   configure script executes. In particular instead of getting "\1" the
   non-printable character "^A" is produced, and causes failures at
   compile time like:
  ../rfb/rfbconfig.h:9:22: warning: extra tokens at end of #ifndef directive

   The workaround is to configure like this:
  env CONFIG_SHELL=/bin/sh /bin/sh ./configure

   i.e. avoid using the bash with the misbehavior. A bug has been filed
   against autoconf to guard against this.

     _________________________________________________________________

   Building on Solaris, FreeBSD, etc:   Depending on your version of
   Solaris or other Unix OS the jpeg and/or zlib libraries may be in
   non-standard places (e.g. /usr/local, /usr/sfw, /opt/sfw, etc).

   Note: If configure cannot find these two libraries then TightVNC and
   ZRLE encoding support will be disabled, and you don't want that! The
   TightVNC encoding gives very good compression and performance, it even
   makes a noticeable difference over a fast LAN.


   Shortcuts: On Solaris 10 you can pick up almost everything just by
   insuring that your PATH has /usr/sfw/bin (for gcc) and /usr/ccs/bin
   (for other build tools), e.g.:
  env PATH=/usr/sfw/bin:/usr/ccs/bin:$PATH sh -c './configure; make'

   (The only thing this misses is /usr/X11/lib/libXrandr.so.2, which is
   for the little used -xrandr option, see the script below to pick it up
   as well).

   libjpeg is included in Solaris 9 and later (/usr/sfw/include and
   /usr/sfw/lib), and zlib in Solaris 8 and later (/usr/include and
   /usr/lib). So on Solaris 9 you can pick up everything with something
   like this:
  env PATH=/usr/local/bin:/usr/ccs/bin:$PATH CPPFLAGS='-I /usr/sfw/include' LDF
LAGS='-L/usr/sfw/lib -R/usr/sfw/lib' sh -c './configure; make'

   assuming your gcc is in /usr/local/bin. Or starting with the 0.7.1
   x11vnc release:
  env PATH=/usr/local/bin:/usr/ccs/bin:$PATH sh -c './configure --with-jpeg=/us
r/sfw; make'

   These are getting pretty long, see those assignments split up in the
   build script below.


   If your system does not have these libraries at all you can get the
   source for the libraries to build them: libjpeg is available at
   [47]ftp://ftp.uu.net/graphics/jpeg/ and zlib at
   [48]http://www.gzip.org/zlib/. See also
   [49]http://www.sunfreeware.com/ for Solaris binary packages of these
   libraries as well as for gcc. Normally they will install into
   /usr/local but you can install them anywhere with the
   --prefix=/path/to/anywhere, etc.


   Here is a build script that indicates one way to pass the library
   locations information to the libvncserver configuration via the
   CPPFLAGS and LDFLAGS environment variables.
#!/bin/sh

# Build script for Solaris, etc, with gcc, libjpeg and libz in
# non-standard locations.

# set to get your gcc, etc:
#
PATH=/path/to/gcc/bin:/usr/ccs/bin:/usr/sfw/bin:$PATH

JPEG=/path/to/jpeg      # set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"
ZLIB=/path/to/zlib      # set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"

# Below we assume headers in $JPEG/include and $ZLIB/include and the
# shared libraries are in $JPEG/lib and $ZLIB/lib.  If your situation
# is different change the locations in the two lines below.
#
CPPFLAGS="-I $JPEG/include -I $ZLIB/include"
LDFLAGS="-L $JPEG/lib -R $JPEG/lib -L $ZLIB/lib -R $ZLIB/lib"

# These two lines may not be needed on more recent Solaris releases:
#
CPPFLAGS="$CPPFLAGS -I /usr/openwin/include"
LDFLAGS="$LDFLAGS -L /usr/openwin/lib -R /usr/openwin/lib"

# These are for libXrandr.so on Solaris 10:
#
CPPFLAGS="$CPPFLAGS -I /usr/X11/include"
LDFLAGS="$LDFLAGS -L /usr/X11/lib -R /usr/X11/lib"

# Everything needs to built with _REENTRANT for thread safe errno:
#
CPPFLAGS="$CPPFLAGS -D_REENTRANT"

export PATH CPPFLAGS LDFLAGS

./configure
make

ls -l ./x11vnc/x11vnc

   Then do make install or copy the x11vnc binary to your desired
   destination.

   BTW, To run a shell script, just cut-and-paste the above into a file,
   say "myscript", then modify the "/path/to/..." items to correspond to
   your system/environment, and then type: "sh myscript" to run it.

   Note that on Solaris make is /usr/ccs/bin/make, so that is why the
   above puts /usr/ccs/bin in PATH. Other important build utilities are
   there too: ld, ar, etc. Also, it is probably a bad idea to have
   /usr/ucb in your PATH while building.

   Starting with the 0.7.1 x11vnc release the "configure --with-jpeg=DIR
   --with-zlib=DIR" options are handy if you want to avoid making a
   script.

   If you need to build on Solaris 2.5.1 or earlier or other older Unix
   OS's, see [50]this workaround FAQ.

   Building on FreeBSD, OpenBSD, ...:   The jpeg libraries seem to be in
   /usr/local or /usr/pkg on these OS's. You won't need the openwin stuff
   in the above script (but you may need /usr/X11R6/...). Also starting
   with the 0.7.1 x11vnc release, this usually works:
  ./configure --with-jpeg=/usr/local
  make

   Building on HP-UX:   For jpeg and zlib you will need to do the same
   sort of thing as described above for Solaris. You set CPPFLAGS and
   LDFLAGS to find them (see below for an example). You do not need to do
   any of the above /usr/openwin stuff. Also, HP-UX does not seem to
   support -R, so get rid of the -R items in LDFLAGS. Because of this, at
   runtime you may need to set LD_LIBRARY_PATH or SHLIB_PATH to indicate
   the directory paths so the libraries can be found. It is a good idea
   to have static archives, e.g. libz.a and libjpeg.a for the nonstandard
   libraries so that they get bolted into the x11vnc binary.

   Finally, there seems to be a bug with configure on HP-UX 11.xx: it
   thinks it cannot find gettimeofday(). As a workaround add this to
   CPPFLAGS: -DLIBVNCSERVER_HAVE_GETTIMEOFDAY=1. You may get some
   warnings but we have verified that this generates working x11vnc
   binaries on HP-UX hppa and ia64. (This problem will be fixed in
   version 0.7.2 by using a newer autoconf).

   Here is what we recently did to build x11vnc 0.7.1 on HP-UX 11.11
env CPPFLAGS="-DLIBVNCSERVER_HAVE_GETTIMEOFDAY=1 -I $HOME/hpux/jpeg/include -I
$HOME/hpux/zlib/include" LDFLAGS="-L $HOME/hpux/jpeg/lib -L $HOME/hpux/zlib/lib
" ./configure
make

   Where we had static archives (libjpeg.a, libz.a) only in the
   $HOME/hpux/... directories.
     _________________________________________________________________

    Beta Testing:

   I don't have any formal beta-testers for the releases of x11vnc, so
   I'd appreciate any additional testing very much!

   I'd like to release version 0.7.2 in Jun/2005 sometime, here is the
   current tarball:

      RC-3 lastmod: 2005-06-20    [51]x11vnc-0.7.2beta.tar.gz

   There are also some Linux and Solaris test binaries [52]here. Please
   kick the tires and report bugs, performance regressions, undesired
   behavior, etc. to [53]me.

   Here is what is shaping up to be [54]the release notes for 0.7.2..
   Note that the [55]X DAMAGE feature will be on by default and so I am
   interested if that causes any problems.

   I'd also like to have the new [56]wireframe move/resize, the
   [57]wireframe copyrect translation, and the [58]scroll
   detection+copyrect features all on by default as well since when they
   work they give a great speedup! (CopyRect is a VNC encoding and is
   very fast because the viewer already has the image data that needs to
   be copied: e.g. it just moves it to another part of its screen). The
   scroll copyrect is currently the least stable, you can toggle it off
   via "-noscr" or via the gui (all of the other new features can also be
   toggled by cmdline option or gui, see -help output for more info).

   I sent [59]this email request to some folks. It contains additional
   info for beta-testing.

   [60]Let me know of any bugs or undesired behavior you find for any of
   these new features. Thanks!
     _________________________________________________________________

    Some Notes:

   Both a client and a server:   It is sometimes confusing to people that
   x11vnc is both a client and a server at the same time. It is an X
   client because it connects to the running X server to do the screen
   polls. Think of it as a rather efficient "screenshot" program running
   continuously. It is a server in the sense that it is a VNC server VNC
   viewers on the network can connect to and view the screen framebuffer
   it manages.

   When trying to debug problems, remember to think of both roles. E.g.
   "how is x11vnc connecting to the X server?", "how is the vncviewer
   connecting to x11vnc?", "what permits/restricts the connection?". Both
   links may have reachability, permission, and other issues.

   Network performance:   Whether you are using Xvnc or x11vnc it is
   always a good idea to have a solid background color instead of a
   pretty background image. Each and every re-exposure of the background
   must be resent over the network: better to have that background be a
   solid color that compresses very well compared to a photo image. (This
   is one place where the X protocol has an advantage over the VNC
   protocol.) I suggest using xsetroot, dtstyle or similar utility to set
   a solid background while using x11vnc. You can turn the pretty
   background image back on when you are using the display directly.
   Update: As of Feb/2005 in the libvncserver CVS, x11vnc has the
   [61]-solid [color] option that works on recent GNOME, KDE, and CDE and
   also on classic X (background image is on the root window).

   I also find the [62]TightVNC encoding gives the best response for my
   usage (Unix <-> Unix over cable modem). One needs a tightvnc-aware
   vncviewer to take advantage of this encoding.

   TCP port issues:   Notice the lines
  18/07/2003 14:36:31 Autoprobing selected port 5900
  PORT=5900

   in the output. 5900 is the default VNC listening port (just like 6000
   is X11's default listening port). Had port 5900 been taken by some
   other application, x11vnc would have next tried 5901. That would mean
   the viewer command above should be changed to vncviewer
   far-away.east:1. You can force the issue with the "[63]-rfbport NNNN"
   option where NNNN is the desired port number. If that port is already
   taken, x11vnc will exit immediately.   (also see the "SunRay Gotcha"
   note below)

   Options:   x11vnc has (far too) many features that may be activated
   via its [64]command line options. Useful options are, e.g., -scale to
   do server-side scaling, and -rfbauth passwd-file to use VNC password
   protection (the vncpasswd or storepasswd programs, or the x11vnc
   [65]-storepasswd option can be used to create the password file).

   Algorithm:   How does x11vnc do it? Rather brute-forcedly: it
   continuously polls the X11 framebuffer for changes using
   XShmGetImage(). When changes are discovered, it instructs libvncserver
   which rectangular regions of the framebuffer have changed, and
   libvncserver compresses the changes and sends them off to any
   connected VNC viewers. A number of applications do similar things,
   such as x0rfbserver, krfb, x0vncserver, vino. x11vnc uses a 32 x 32
   pixel tile model (the desktop is decomposed into roughly 1000 such
   tiles), where changed tiles are found by pseudo-randomly polling 1
   pixel tall horizontal scanlines. This is a surprisingly effective
   algorithm for finding changed regions. For keyboard and mouse user
   input the XTEST extension is used to pass the input events to the X
   server. To detect XBell "beeps" the XKEYBOARD extension is used. If
   available, the XFIXES extension is used to retrieve the current mouse
   cursor shape. Also, if available the X DAMAGE extension is used to
   receive hints from the X server where modified regions on the screen
   are. This greatly reduces the system load when not much is changing on
   the screen and also improves how quickly the screen is updated.

   Barbershop mirrors effect:   What if x11vnc is started up, and
   vncviewer is then started up on the same machine and displayed on the
   same display x11vnc is polling? One might "accidentally" do this when
   first testing out the programs. You get an interesting "feedback"
   effect where vncviewer images keep popping up each one contained in
   the previous one and slightly shifted a bit by the window manager
   decorations. There will be an [66]even more interesting effect if
   -scale is used. Also, if the XKEYBOARD is supported and the XBell
   "beeps" once, you get an infinite loop of beeps going off. Although
   all of this is mildly exciting it is not much use: you will normally
   run and display the viewer on a different machine!

   SunRay notes:   You can run x11vnc on your (connected or disconnected)
   [67]SunRay session (Please remember to use [68]-nap and maybe
   [69]-wait 200 to avoid being a resource hog! It also helps to have a
   solid background color). You have to know the name of the machine your
   SunRay session X server is running on. You also need to know the X11
   DISPLAY number for the session: on a SunRay it could be a large
   number, e.g. :137, since there are many people with X sessions (Xsun
   processes) on the same machine. If you don't know it, you can get it
   by running who(1) in a shell on the SunRay server and looking for the
   dtlocal entry with your username (and if you don't even know which
   server machine has your session, you could login to all possible ones
   looking at the who output for your username...).

   I put some code in my ~/.xsession script that stores $DISPLAY in my
   ~/.sunray_current file at session startup and deletes it when the
   session ends to make it easy to get at the hostname and X11 display
   number info for my current X sessions.

   SunRay Gotcha #1:   Note that even though your SunRay X11 DISPLAY is
   something like :137, x11vnc still tries for port 5900 as its listening
   port if it can get it, in which case the VNC display (i.e. the
   information you supply to the VNC viewer) is something like
   sunray-server:0   (note the :0 corresponding to port 5900, it is not
   :137). If it cannot get 5900, it tries for 5901, and so on. You can
   also try to force the port (and thereby the VNC display) using the
   [70]-rfbport NNNN option.

   SunRay Gotcha #2:   If you get an error like:
        shmget(tile) failed.
        shmget: No space left on device

   when starting up x11vnc that most likely means all the shared memory
   (shm) slots are filled up on your machine. The Solaris default is only
   100, and that can get filled up in a week or so on a SunRay server
   with lots of users. If the shm slot is orphaned (e.g. creator process
   dies) the slot is not reclaimed. You can view the shm slots with the
   "ipcs -mA" command. If there are about 100 then you've probably hit
   this problem. They can be cleaned out (by the owner or by root) using
   the ipcrm command. I wrote a script [71]shm_clear that finds the
   orphans and lists or removes them. Longer term, have your SunRay
   sysadmin add something like this to /etc/system:
        set shmsys:shminfo_shmmax = 0x2000000
        set shmsys:shminfo_shmmni = 0x1000

    Limitations:

     * Due to the polling nature, some activities (opaque window moves,
       scrolling), can be pretty choppy/ragged and others (exposures of
       large areas) slow. Experiment with interacting a bit differently
       than you normally do to minimize the effects (e.g. do fullpage
       paging rather than line-by-line scrolling, and move windows in a
       single, quick motion). Work is in progress to attempt to speed
       things up using the copyrect encoding and other things, but they
       will likely only speed up certain activities, not all.
     * A rate limiting factor for x11vnc performance is that video
       hardware is optimized for writing, not reading (x11vnc reads the
       video framebuffer for the screen image data). The difference can
       be a factor of 10 to 1000, and so it usually takes about 0.5-1 sec
       to read in the whole video hardware framebuffer (e.g. 5MB for
       1280x1024 at depth 24 with a read rate of 5-10MB/sec). So whenever
       activity changes most of the screen (e.g. moving or iconifying a
       large window) there is a delay of 0.5-1 sec while x11vnc reads the
       changed regions in.
       Note: A quick way to get a 2X speedup is to switch from depth 24
       (32bpp) to depth 16 (16bpp). You get a 4X speedup going to 8bpp,
       but the lack of color cells is usually unacceptable.
       To get a sense of the read and write speeds of your video card,
       you can run the benchmarks like: x11perf -getimage500,  x11perf
       -putimage500,  x11perf -shmput500 and for XFree86 displays with
       direct graphics access the dga command (press "b" to run the
       benchmark and then after a few seconds press "q" to quit). Even
       this "dd if=/dev/fb0 of=/dev/null" often gives a good estimate. We
       have seen a few cases where the hardware fb read speed is greater
       than 65 MB/sec: on high end graphics workstations from SGI and
       Sun, and also from a Linux user using nvidia proprietary drivers
       for his nvidia video card. If you have a card with a fast read
       speed please send us the details.
       On XFree86 it is actually possible to increase the framebuffer
       read speed considerably (5-100 times) by using the Shadow
       Framebuffer (a copy of the framebuffer is kept in main memory and
       this can be read much more quickly). To do this one puts the line
       Option "ShadowFB" "true" (and depending on video card driver,
       Option "NoAccel" "true" may be needed too) in the Device section
       of the /etc/X11/XF86Config file. Note that this disables 2D
       acceleration at the physical display and so likely defeats the
       purpose. Nevertheless this could be handy in some circumstances,
       e.g. if the slower speed while sitting at the physical display was
       acceptable (this seems to be true for most video cards these
       days). Unfortunately it does not seem shadowfb can be turned on
       and off dynamically...
       Another amusing thing one can do is use Xvfb as the X server, e.g.
       "xinit $HOME/.xinitrc -- /usr/X11R6/bin/Xvfb :1 -screen 0
       1024x768x16" x11vnc can poll Xvfb efficiently via main memory.
       It's not exactly clear why one would want to do this (perhaps to
       take advantage of an x11vnc feature, such as framebuffer scaling),
       instead of using vncserver/Xvnc, but we mention it because it may
       be of use for special purpose applications.
     * Somewhat surprisingly, the X11 mouse (cursor) shape is write-only
       and cannot be queried from the X server. So in x11vnc the cursor
       shape stays fixed at an arrow. (see the "-cursor X" and "-cursor
       some" [72]options, however, for a partial hack for the root
       window, etc.). Also, on Solaris using the SUN_OVL overlay
       extension, x11vnc can show the correct mouse cursor when the
       [73]-overlay option is also supplied. A similar thing is done on
       IRIX as well when -overlay is supplied. As of Dec/2004 x11vnc
       supports the XFIXES extension (in Xorg and Solaris 10) to query
       the X server for the exact cursor shape, this works pretty well
       except that cursors with transparency (alpha channel) need to
       approximated to solid RGB values.
     * Audio from applications is of course not redirected (separate
       redirectors do exist, e.g. esd). The XBell() "beeps" will work if
       the X server supports the XKEYBOARD extension. (Note that on
       Solaris XKEYBOARD is disabled by default. Passing +kb to Xsun
       enables it).
     * Occasionally a patch of tiles will not get updated correctly.
       Evidently a timing related bug and difficult to reproduce...
     * Using -threads can expose some bugs in libvncserver.

   Please feel free to [74]contact me if you have any questions,
   problems, or comments about x11vnc, etc.
   Also, some people ask if they can make a donation, see [75]this link
   for that.
     _________________________________________________________________

    x11vnc FAQ:


   [Building and Starting]

   [76]Q-1: I can't get x11vnc to start up. It says "XOpenDisplay failed
   (null)" or "Xlib: connection to ":0.0" refused by server Xlib: No
   protocol specified" and then exits. What do I need to do? 

   [77]Q-2: I can't get x11vnc and/or libvncserver to compile. 

   [78]Q-3: I just built x11vnc successfully, but when I use it my
   keystrokes and mouse button clicks are ignored  (I am able to move the
   mouse though). 

   [79]Q-4: Help, I need to run x11vnc on Solaris 2.5.1 (or other old
   Unix/Linux) and it doesn't compile! 

   [80]Q-5: Where can I get a precompiled x11vnc binary for my Operating
   System? 

   [81]Q-6: Where can I get a VNC Viewer binary (or source code) for the
   Operating System I will be viewing from? 

   [82]Q-7: How can I see all of x11vnc's command line options and
   documentation on how to use them? 

   [83]Q-8: I don't like typing arcane command line options every time I
   start x11vnc. What can I do? Is there a config file? Or a GUI? 

   [84]Q-9: Can I make x11vnc more quiet and also go into the background
   after starting up? 

   [85]Q-10: Sometimes when a VNC viewer dies abruptly, x11vnc also dies
   with the error message like: "Broken pipe". I'm using the -forever
   mode and I want x11vnc to keep running. 

   [86]Q-11: Are there any build-time customizations possible, e.g.
   change defaults, create a smaller binary, etc? 

   [Win2VNC Related]

   [87]Q-12: I have two separate machine displays in front of me, one
   Windows the other X11: can I use x11vnc in combination with Win2VNC in
   dual-screen mode to pass the keystrokes and mouse motions to the X11
   display? 

   [88]Q-13: I am running Win2VNC on my Windows machine and "x11vnc
   -nofb" on Unix to pass keyboard and mouse to the Unix monitor.
   Whenever I start Win2VNC it quickly disconnects and x11vnc says:
   rfbProcessClientNormalMessage: read: Connection reset by peer 

   [Color Issues]

   [89]Q-14: The X display I run x11vnc on is only 8 bits per pixel (bpp)
   PseudoColor (i.e. only 256 distinct colors). The x11vnc colors may
   start out OK, but after a while they are incorrect in certain windows.
   
   [90]Q-15: Color problems: Why are the colors for some windows messed
   up in x11vnc? BTW, my X display has nice overlay/multi-depth visuals
   of different color depths: e.g. there are both depth 8 and 24 visuals
   available at the same time. 

   [91]Q-16: How do I figure out the window id to supply to the -id
   windowid option? 

   [92]Q-17: Why don't menus or other transient windows come up when I am
   using the -id windowid option to view a single application window? 

   [93]Q-18: My X display is depth 24 at 24bpp (instead of the normal
   depth 24 at 32bpp). I'm having lots of color and visual problems with
   x11vnc and/or vncviewer. What's up? 

   [Xterminals]

   [94]Q-19: Can I use x11vnc to view and interact with an Xterminal
   (e.g. NCD) that is not running UNIX and so x11vnc cannot be run on it
   directly? 

   [95]Q-20: How do I get my X permissions (MIT-MAGIC-COOKIE) correct for
   a Unix/Linux machine acting as an Xterminal? 

   [Remote Control]

   [96]Q-21: How do I stop x11vnc once it is running in the background? 

   [97]Q-22: Can I change settings in x11vnc without having to restart
   it? Can I remote control it? 

   [Security and Permissions]

   [98]Q-23: How do I create a VNC password for use with x11vnc? 

   [99]Q-24: Can I have two passwords for VNC viewers, one for full
   access and the other for view-only access to the display? 

   [100]Q-25: Can I fine tune what types of user input are allowed? E.g.
   have some users just be able to move the mouse, but not click or type
   anything? 

   [101]Q-26: Why does x11vnc exit as soon as the VNC viewer disconnects?
   And why doesn't it allow more than one VNC viewer to connect at the
   same time? 

   [102]Q-27: Can I limit which machines incoming VNC clients can connect
   from? 

   [103]Q-28: How do I build x11vnc/libvncserver with libwrap
   (tcp_wrappers) support? 

   [104]Q-29: Can I have x11vnc only listen on one network interface
   (e.g. internal LAN) rather than having it listen on all network
   interfaces and relying on -allow to filter unwanted connections out? 

   [105]Q-30: Now that -localhost implies listening only on the loopback
   interface, how I can occasionally allow in a non-localhost via the
   allowonce remote control command? 

   [106]Q-31: How can I tunnel my connection to x11vnc via an encrypted
   SSH channel between two Unix machines? 

   [107]Q-32: How can I tunnel my connection to x11vnc via an encrypted
   SSH channel from Windows using an SSH client like Putty? 

   [108]Q-33: Can I prompt the user at the local X display whether the
   incoming VNC client should be accepted or not? Can I decide to make
   some clients view-only? How about running an arbitrary program to make
   the decisions? 

   [109]Q-34: Does x11vnc support Unix usernames and passwords? Can I
   further limit the set of Unix usernames who can connect to the VNC
   desktop? 

   [110]Q-35: I start x11vnc as root because it is launched via inetd(1)
   or a display manager like gdm(1). Can I have x11vnc later switch to a
   different user? 

   [111]Q-36: I use a screen-lock when I leave my workstation (e.g.
   xscreensaver or xlock). When I remotely access my workstation desktop
   via x11vnc I can unlock the desktop fine, but I am worried people will
   see my activities on the physical monitor. What can I do to prevent
   this, or at least make it more difficult? 

   [112]Q-37: Can I have x11vnc automatically lock the screen when I
   disconnect the VNC viewer? 

   [Display Managers and Services]

   [113]Q-38: How can I run x11vnc as a "service" that is always
   available? 

   [114]Q-39: How can I use x11vnc to connect to an X login screen like
   xdm, GNOME gdm, KDE kdm, or CDE dtlogin? (i.e. nobody is logged into
   an X session yet). 

   [115]Q-40: Can I run x11vnc out of inetd(1)? How about xinetd(1)? 

   [116]Q-41: How do I make x11vnc work with the Java VNC viewer applet
   in a web browser? 

   [117]Q-42: Are reverse connections (i.e. the VNC server connecting to
   the VNC viewer) using "vncviewer -listen" and vncconnect(1) supported?
   
   [118]Q-43: Can I use x11vnc as a replacement for Xvnc? (i.e. not for a
   real display, but for a virtual one I keep around). 

   [119]Q-44: How can I use x11vnc on "headless" machines? Why might I
   want to? 

   [Resource Usage and Performance]

   [120]Q-45: I have lots of memory, but why does x11vnc fail with
   shmget: No space left on device    or    Minor opcode of failed
   request: 1 (X_ShmAttach)? 

   [121]Q-46: How can I make x11vnc use less system resources? 

   [122]Q-47: How can I make x11vnc use MORE system resources? 

   [123]Q-48: I use x11vnc over a slow link with high latency (e.g.
   dialup modem), is there anything I can do to speed things up? 

   [124]Q-49: Does x11vnc support the X DAMAGE Xserver extension to find
   modified regions of the screen quickly and efficiently? 

   [125]Q-50: When I drag windows around with the mouse or scroll up and
   down things really bog down (unless I do the drag in a single, quick
   motion). Is there anything to do to improve things? 

   [126]Q-51: Why not do something like wireframe animations to avoid the
   windows "lurching" when being moved or resized? 

   [127]Q-52: Can x11vnc try to apply heuristics to detect when an window
   is scrolling its contents and use the CopyRect encoding for a speedup?
   
   [Mouse Cursor Shapes]

   [128]Q-53: Why isn't the mouse cursor shape (the little icon shape
   where the mouse pointer is) correct as I move from window to window? 

   [129]Q-54: When using XFIXES cursorshape mode, some of the cursors
   look really bad with extra black borders around the cursor and other
   cruft. How can I improve their appearance? 

   [130]Q-55: In XFIXES mode, are there any hacks to handle cursor
   transparency ("alpha channel") exactly? 

   [Mouse Pointer]

   [131]Q-56: Why does the mouse arrow just stay in one corner in my
   vncviewer, whereas my cursor (that does move) is just a dot? 

   [132]Q-57: Can I take advantage of the TightVNC extension to the VNC
   protocol where Cursor Positions Updates are sent back to all connected
   clients (i.e. passive viewers can see the mouse cursor being moved
   around by another viewer)? 

   [133]Q-58: Is it possible to swap the mouse buttons (e.g. left-handed
   operation), or arbitrarily remap them? How about mapping button clicks
   to keystrokes, e.g. to partially emulate Mouse wheel scrolling? 

   [Keyboard Issues]

   [134]Q-59: How can I get my AltGr and Shift modifiers to work between
   keyboards for different languages? 

   [135]Q-60: When I try to type a "<" (i.e. less than) instead I get ">"
   (i.e. greater than)! Strangely, typing ">" works OK!! 

   [136]Q-61: I'm using an "international" keyboard (e.g. German "de", or
   Danish "dk") and the -modtweak mode works well if the VNC viewer is
   run on a Unix/Linux machine with a similar keyboard.   But if I run
   the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or
   Windows with any keyboard, I can't type some keys like:   "@", "$",
   "<", ">", etc. How can I fix this? 

   [137]Q-62: When typing I sometimes get double, triple, or more of my
   keystrokes repeated. I'm sure I only typed them once, what can I do? 

   [138]Q-63: The x11vnc -norepeat mode is in effect, but I still get
   repeated keystrokes!! 

   [139]Q-64: The machine where I run x11vnc has an AltGr key, but the
   local machine where I run the VNC viewer does not. Is there a way I
   can map a local unused key to send an AltGr? How about a Compose key
   as well? 

   [140]Q-65: I have a Sun machine I run x11vnc on. Its Sun keyboard has
   just one Alt key labelled "Alt" and two Meta keys labelled with little
   diamonds. The machine where I run the VNC viewer only has Alt keys.
   How can I send a Meta keypress? (e.g. emacs needs this) 

   [141]Q-66: Can I map a keystroke to a mouse button click on the remote
   machine? 

   [Screen Related Issues and Features]

   [142]Q-67: The remote display is larger (in number of pixels) than the
   local display I am running the vncviewer on. I don't like the
   vncviewer scrollbars, what I can do? 

   [143]Q-68: Does x11vnc support server-side framebuffer scaling? (E.g.
   to make the desktop smaller). 

   [144]Q-69: Does x11vnc work with Xinerama? (i.e. multiple monitors
   joined together to form one big, single screen). 

   [145]Q-70: Can I use x11vnc on a multi-headed display that is not
   Xinerama (i.e. separate screens :0.0, :0.1, ... for each monitor)? 

   [146]Q-71: Can x11vnc show only a portion of the display? (E.g. for a
   special purpose rfb application). 

   [147]Q-72: Does x11vnc support the XRANDR (X Resize, Rotate and
   Reflection) extension? Whenever I rotate or resize the screen x11vnc
   just seems to crash. 

   [148]Q-73: Why is the view in my VNC viewer completely black? Or why
   is everything flashing around randomly? 

   [149]Q-74: I use Linux Virtual Consoles (VC's) to implement 'Fast User
   Switching' between users' sessions (e.g. Betty is on Ctrl-Alt-F7,
   Bobby is on Ctrl-Alt-F8, and Sid is on Ctrl-Alt-F1: they use those
   keystrokes to switch between their sessions).   How come the view in a
   VNC viewer connecting to x11vnc is either completely black or
   otherwise all messed up unless the X session x11vnc is attached to is
   in the active VC? 

   [150]Q-75: Can I use x11vnc to view my VMWare session remotely? 

   [151]Q-76: Can non-X devices (e.g. a raw framebuffer) be viewed and/or
   controlled by x11vnc? 

   [152]Q-77: I am using x11vnc where my local machine has "popup/hidden
   taskbars" (e.g. GNOME or MacOS X) and the remote display where x11vnc
   runs also has "popup/hidden taskbars" (e.g. GNOME). When I move the
   mouse to the edge of the screen where the popups happen, the taskbars
   interfere and fight with each other in strange ways. What can I do? 

   [Misc: Clipboard, Beeps, Thanks, etc.]

   [153]Q-78: Does the Clipboard/Selection get transferred between the
   vncviewer and the X display? 

   [154]Q-79: Why don't I hear the "Beeps" in my X session (e.g. when
   typing tput bel in an xterm)? 

   [155]Q-80: Thanks for your program and for your help! Can I make a
   donation? 
     _________________________________________________________________


   [Building and Starting]

   Q-1: I can't get x11vnc to start up. It says "XOpenDisplay failed
   (null)" or "Xlib: connection to ":0.0" refused by server Xlib: No
   protocol specified" and then exits. What do I need to do?

   For the former error, you need to specify the X display to connect to
   (it also needs to be on the same machine x11vnc is to run on). Set
   your DISPLAY environment variable or use the [156]-display option to
   specify it. Nearly always the correct value will be ":0"


   For the latter error, you need to set up the X11 permissions
   correctly.

   To make sure X11 permissions are the problem do this simple test:
   while sitting at the physical X display open a terminal window
   (gnome-terminal, xterm, etc). You should be able to start x11vnc
   without any need for special steps or command line options in that
   terminal. If that works OK then you know X11 permissions are the only
   thing preventing it from working when you try to start x11vnc via,
   say, a remote shell.

   How to Solve:  See the xauth(1), Xsecurity(7), and xhost(1) man pages
   for much info on X11 permissions. For example, you may need to set
   your XAUTHORITY environment variable or use the [157]-auth option to
   point to the correct MIT-MAGIC-COOKIE file (e.g. /home/joe/.Xauthority
   or /var/gdm/:0.Xauth), or simply be sure you run x11vnc as the correct
   user (i.e. the user who owns the X session you wish to view).

   The cookie file contains the secret key that allows x11vnc to connect
   to the desired X display.

   If, say, sshd has set XAUTHORITY to point to a random file it has
   created for X forwarding that will cause problems. (Under some
   circumstances even su(1) and telnet(1) can set XAUTHORITY.) Running
   x11vnc as root is often not enough: you need to know where the
   MIT-MAGIC-COOKIE file for the desired X display is.   Example
   solution:
  x11vnc -display :0 -auth /var/gdm/:0.Xauth

   (this is for the display manager gdm, see [158]this faq for other
   display manager cookie file names).

   Less safe, but to avoid figuring out where the XAUTHORITY file is, if
   the person sitting at the X session types "xhost +localhost" then one
   should be able to attach x11vnc to the session (from the same
   machine). The person could then type "xhost -localhost" after x11vnc
   has connected to go back to the default permissions. Also, for some
   situations the "-users lurk=" option may be of use (please read the
   documentation on the [159]-users option).

   To test out your X11 permissions from a remote shell, set DISPLAY and
   possibly XAUTHORITY (see your shell's man page, bash(1), tcsh(1), on
   how to set environment variables) and type xdpyinfo in the same place
   you will be typing (or otherwise running) x11vnc. If information is
   printed out about the X display (screen sizes, supported extensions,
   color visuals info) that means the X11 permissions are set up
   properly: xdpyinfo successfully connected to DISPLAY! You could also
   type xclock and make sure no errors are reported (a clock should
   appear on the X display, press Ctrl-C to stop it). If these work, then
   typing "x11vnc" should also work.

   Important: if you cannot get your X11 permissions so that the xdpyinfo
   or xclock tests work, x11vnc also will not work (all of these X
   clients must be allowed to connect to the X server to function
   properly).


   Q-2: I can't get x11vnc and/or libvncserver to compile.

   Make sure you have all of the required -devel packages installed.
   These include X11/XFree86, libjpeg, libz, ...

   After running the libvncserver configure, carefully examine the output
   and the messages in the config.log file looking for missing
   components. If the configure output looks like:
  checking how to run the C preprocessor... gcc -E
  checking for X... no
  checking for XkbSelectEvents in -lX11... no
  checking for XineramaQueryScreens in -lXinerama... no
  checking for XTestFakeKeyEvent in -lXtst... no

   there is quite a bit wrong with the build environment. Hopefully
   simply adding -devel packages will fix it.

   For Debian the list seems to be:
  gcc
  make
  libc6-dev
  libjpeg62-dev
  libx11-dev
  libxext-dev
  libxrandr-dev
  libxtst-dev
  x-dev
  xlibs-static-dev
  zlib1g-dev

   For Redhat the list seems to be:
  gcc
  make
  glibc-devel
  libjpeg-devel
  XFree86-devel
  zlib-devel


   Q-3: I just built x11vnc successfully, but when I use it my keystrokes
   and mouse button clicks are ignored  (I am able to move the mouse
   though).

   This is most likely due to you not having a working build environment
   for the XTEST client library libXtst.so. The library is probably
   present on your system, but the package installing the development
   header file is missing.

   If you were watching carefully while configure was running you would
   have seen:
  checking for XTestFakeKeyEvent in -lXtst... no

   The solution is to add the necessary build environment package (and
   the library package if that is missing too). On Debian the build
   package is libxtst-dev. Other distros/OS's may have it in another
   package.

   x11vnc will build without support for this library (e.g. perhaps one
   wants a view-only x11vnc on a stripped down or embedded system...). At
   runtime it will also continue to run even if the X server it connects
   to does not support XTEST. In both cases it cannot inject keystrokes
   or button clicks since XTEST is needed for that (it can still move the
   mouse pointer using the X API XWarpPointer()).

   You will see a warning message something like this at run time:
  20/03/2005 22:33:09 WARNING: XTEST extension not available (either missing fr
om
  20/03/2005 22:33:09   display or client library libXtst missing at build time
).
  20/03/2005 22:33:09   MOST user input (pointer and keyboard) will be DISCARDE
D.
  20/03/2005 22:33:09   If display does have XTEST, be sure to build x11vnc wit
h
  20/03/2005 22:33:09   a working libXtst build environment (e.g. libxtst-dev,
  20/03/2005 22:33:09   or other packages).
  20/03/2005 22:33:09 No XTEST extension, switching to -xwarppointer mode for
  20/03/2005 22:33:09   pointer motion input.


   Q-4: Help, I need to run x11vnc on Solaris 2.5.1 (or other old
   Unix/Linux) and it doesn't compile!

   We apologize that x11vnc does not build cleanly on older versions of
   Solaris, Linux, etc.: very few users are on these old releases.

   We have heard that since Dec/2004 a Solaris 2.6 built x11vnc will run
   on Solaris Solaris 2.5 and 2.5.1 (since a workaround for XConvertCase
   is provided).

   In any event, here is a workaround for Solaris 2.5.1 (and perhaps
   earlier and perhaps non-Solaris):

   First use the environment settings (CPPFLAGS, LDFLAGS, etc.) in the
   above [160]Solaris build script to run the configure command. That
   should succeed without failure. Then you have to hand edit the
   autogenerated rfb/rfbconfig.h file in the source tree, and just before
   the last #endif at the bottom of that file insert these workaround
   lines:
struct timeval _tmp_usleep_tv;
#define usleep(x) \
    _tmp_usleep_tv.tv_sec  = (x) / 1000000; \
    _tmp_usleep_tv.tv_usec = (x) % 1000000; \
    select(0, NULL, NULL, NULL, &_tmp_usleep_tv);
int gethostname(char *name, int namelen);
long random();
int srandom(unsigned int seed);
#undef LIBVNCSERVER_HAVE_LIBPTHREAD
#define SHUT_RDWR 2
typedef unsigned int in_addr_t;
#define snprintf(a, n, args...) sprintf((a), ## args)

   Then run make with the Solaris build script environment, everything
   should compile without problems, and the resulting x11vnc binary
   should work OK. If some non-x11vnc related programs fail (e.g. test
   programs) and the x11vnc binary is not created try "make -k" to have
   it keep going. Similar sorts of kludges in rfb/rfbconfig.h can be done
   on other older OS (Solaris, Linux, ...) releases.

   Here are some notes for similar steps that need to be done to build on
   [161]SunOS 4.x

   Please let us know if you had to use the above workaround (and whether
   it worked or not). If there is enough demand we will try to push clean
   compilations back to earlier Solaris, Linux, etc, releases.


   Q-5: Where can I get a precompiled x11vnc binary for my Operating
   System?

   Hopefully the [162]build steps above and [163]FAQ provide enough info
   for a painless compile for most environments. Please report problems
   with the x11vnc configure, make, etc. on your system (if your system
   is known to compile other GNU packages successfully).

   There are precompiled x11vnc binaries built by other groups that are
   available at the following locations:
    Debian:         (.deb)  [164]http://packages.debian.org/x11vnc

   Slackware: (.tgz) [165]http://www.linuxpackages.net/ Redhat/Fedora:
   (.rpm) [166]http://dag.wieers.com/packages/x11vnc/ SuSE: (.rpm)
   [167]http://linux01.gwdg.de/~pbleser/ Solaris: (pkg)
   [168]http://www.sunfreeware.com/ wwexptools: (.tgz)
   [169]http://www.bell-labs.com/project/wwexptools/packages.html The
   last one, wwexptools, provides a variety of Unix binaries (Linux,
   Solaris, HP-UX, IRIX, ...) with the intent of being compatible on a
   wide range of OS releases. Find x11vnc near the bottom of that page
   and select 'download info'.

   Note: it appears some of the wwexptools x11vnc binaries are not
   compiled with libz and libjpeg and so the fast compression encodings:
   "Tight", "ZRLE", etc are not supported by those binaries. You can see
   this by looking at the x11vnc output and if it says the encoding for a
   client is "hextile" then likely the fast compression encodings are
   missing. If you want optimal performance on your OS, you should see
   the [170]build notes above for where to download libz and libjpeg, and
   then build everything with gcc. For Solaris, the
   http://www.sunfreeware.com/ packages are built with libz and libjpeg.

   If the above binaries don't work and building x11vnc on your OS fails
   (and all else fails!) you can try one of my motley collection of
   [171]test binaries. Some may be old, some may have extra debugging
   output, etc. One of them may work on your OS...

   As a general note, the x11vnc program is simple enough you don't
   really need to install a package: the binary will in most cases work
   as is and from any location (as long as your system libraries are not
   too old, etc). So, for Linux distributions that are not one of the
   above, the x11vnc binary from the above packages has a good chance of
   working. You can "install" it by just copying the x11vnc binary to the
   desired directory in your PATH. Tip on extracting files from a Debian
   package: extract the archive via a command like: "ar x
   x11vnc_0.6-2_i386.deb" and then you can find the binary in the
   resulting data.tar.gz tar file. Also, rpm2cpio(1) is useful in
   extracting files from rpm packages.


   Q-6: Where can I get a VNC Viewer binary (or source code) for the
   Operating System I will be viewing from?

   To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix)
   try here:
     * [172]http://www.tightvnc.com/download.html
     * [173]http://www.realvnc.com/download-free.html
     * [174]http://sourceforge.net/projects/cotvnc/


   Q-7: How can I see all of x11vnc's command line options and
   documentation on how to use them?

   Run:  x11vnc -opts   to list just the option names or run:  x11vnc
   -help   for long descriptions about each option. The output is listed
   [175]here as well.


   Q-8: I don't like typing arcane command line options every time I
   start x11vnc. What can I do? Is there a config file? Or a GUI?

   You could create a shell script that calls x11vnc with your options:
#!/bin/sh
#
# filename: X11vnc  (i.e. not "x11vnc")
# It resides in a directory in $PATH. "chmod 755 X11vnc" has been run on it.
#
x11vnc -nap -wait 50 -localhost -rfbauth $HOME/.vnc/passwd -display :0 $*

   a similar thing can be done via aliases in your shell (bash, tcsh,
   csh, etc..).

   Or as of Jun/2004 in the libvncserver CVS you can use the simple
   $HOME/.x11vncrc config file support. If that file exists, each line is
   taken as a command line option. E.g. the above would be:
# this is a comment in my ~/.x11vncrc file
nap
wait 50        # this is a comment to the end of the line.
-localhost     # note: the leading "-" is optional.
rfbauth  /home/fred/.vnc/passwd
display :0

   At some point this config file support will be expanded.

   As of Dec/2004 in the libvncserver CVS there is now a simple tcl/tk
   GUI based on the remote-control functionality that was added. It's not
   particularly user-friendly, it just provides a point and click mode to
   set all the many x11vnc parameters and obtain help on them. See the
   [176]-gui option for more info. Examples: "x11vnc ... -gui" and
   "x11vnc ... -gui other:0" in the latter case the gui is displayed on
   other:0, not the X display x11vnc is polling.


   Q-9: Can I make x11vnc more quiet and also go into the background
   after starting up?

   Use the [177]-q and [178]-bg options, respectively.  (also: -quiet is
   an alias for -q)

   Note that under -bg the stderr messages will be lost unless you use
   the "[179]-o logfile" option.


   Q-10: Sometimes when a VNC viewer dies abruptly, x11vnc also dies with
   the error message like: "Broken pipe". I'm using the -forever mode and
   I want x11vnc to keep running.

   As of Jan/2004 in the libvncserver CVS the SIGPIPE signal is ignored.
   So if a viewer client terminates abruptly, libvncserver will notice on
   the next I/O operation and will close the connection and continue on.

   Up until of Apr/2004 the above fix only works for BSD signal systems
   (Linux, FreeBSD, ...) For SYSV systems there is a workaround in place
   since about Jun/2004.


   Q-11: Are there any build-time customizations possible, e.g. change
   defaults, create a smaller binary, etc?

   As of Mar/2004 in the libvncserver cvs there are a few such options.
   They are enabled by adding something like -Dxxxx=1 to the CPPFLAGS
   environment variable before running configure (see the [180]build
   notes for general background).
     * -DX11VNC_SHARED=1   make -shared the default.
     * -DX11VNC_FOREVER=1   make -forever the default.
     * -DREMOTE_CONTROL=0   disable the remote control mechanism.
     * -DSMALL_FOOTPRINT=1   strip out help text, gui, etc to make a
       smaller binary (e.g. for PDA or embedded system with low disk
       space). Also be sure to strip(1) the binary. Set to 2 or 3 to cut
       out even more.

   For example:
  env CPPFLAGS="-DX11VNC_FOREVER=1" ./configure; make

   If other things (e.g. "-I ...") are needed in CPPFLAGS add them as
   well.

   Be careful the the following two variables: HARDWIRE_PASSWD and
   HARDWIRE_VIEWPASSWD. If set (remember to include the double quotes
   around the string), they will be used as default values for the
   -passwd and -viewpasswd options. Of course the strings will exist
   unobscured in the x11vnc: the binary better not be readable by
   unintendeds. Perhaps this is of use in remote access for an embedded
   application, etc...

   Let us know if more build-time customizations would be useful. Look
   near the top of the source file for any additional customization
   macros.

   If the system does not have the XTEST XTestGrabControl interface (some
   early X11R5 systems have XTEST but not this interface), then configure
   will automatically try to see if the DEC-XTRAP extension build
   environment is available and use that for avoiding GrabServer
   deadlock. If you want DEC-XTRAP compiled in no matter what, set
   X11VNC_USE_XTRAP=1 in your environment. Note that DEC-XTRAP should
   only be used as a last resort on legacy machines since the standard
   XTEST works well. If there is interest for legacy machines to use
   DEC-XTRAP for all of the user input injection (not just grab control)
   let us know and we will put it in for you to try. (Note: DEC-XTRAP
   grab control seems to be broken on Linux/XFree86)

   [Win2VNC Related]

   Q-12: I have two separate machine displays in front of me, one Windows
   the other X11: can I use x11vnc in combination with Win2VNC in
   dual-screen mode to pass the keystrokes and mouse motions to the X11
   display?

   Yes, for best response start up x11vnc with the "[181]-nofb" option
   (disables framebuffer polling, and does other optimizations) on the
   secondary display (X11) machine. Then start up Win2VNC on the primary
   display (Windows) referring it to the secondary display.

   This will also work X11 to X11 using [182]x2vnc, however you would
   probably just want to avoid VNC and use x2x for that.

   For reference, here are some links to Win2VNC-like programs for
   multiple monitor setups:
     * [183]Original Win2VNC
     * [184]Enhanced Win2VNC and [185]sourceforge link
     * [186]x2vnc
     * [187]x2x also [188]here
     * [189]zvnc (MorphOS)

   All of them will work with x11vnc (except x2x where it is not needed).


   Q-13: I am running Win2VNC on my Windows machine and "x11vnc -nofb" on
   Unix to pass keyboard and mouse to the Unix monitor. Whenever I start
   Win2VNC it quickly disconnects and x11vnc says:
   rfbProcessClientNormalMessage: read: Connection reset by peer

   Is the default visual of the X display you run x11vnc on low color
   (e.g. 8 bit per pixel PseudoColor)? (you can run xdpyinfo to check,
   look in the "screen" section). There seems to be a bug in Win2VNC in
   that it cannot deal correctly with colormaps (PseudoColor is the most
   common example of a visual with a colormap).

   If so, there are a couple options. 1) Can you set the default visual
   on your display to be depth 24 TrueColor? Sun machines often have 8+24
   overlay/multi-depth visuals, and you can make the default visual depth
   24 TrueColor (see fbconfig(1) and Xsun(1)). 2) As of Feb/2004, in the
   libvncserver CVS, x11vnc has the [190]-visual option to allow you to
   force the framebuffer visual to whatever you want (this usually messes
   up the colors unless you are very clever). In this case, the option
   provides a convenient workaround for the Win2VNC bug:
  x11vnc -nofb -visual TrueColor -display :0 ...

   So the visual will be set to 8bpp TrueColor and Win2VNC can handle
   this. Since Win2VNC does not use the framebuffer data there should be
   no problems in doing this.
   [Color Issues]

   Q-14: The X display I run x11vnc on is only 8 bits per pixel (bpp)
   PseudoColor (i.e. only 256 distinct colors). The x11vnc colors may
   start out OK, but after a while they are incorrect in certain windows.

   Use the [191]-flashcmap option to have x11vnc watch for changes in the
   colormap, and propagate those changes back to connected clients. This
   can be slow (since the whole screen must be updated over the network
   whenever the colormap changes). This flashing colormap behavior often
   happens if an application installs its own private colormap when the
   mouse is in its window. "netscape -install" is a well-known historical
   example of this. Consider reconfiguring the system to 16 bpp or depth
   24 TrueColor if at all possible.

   Also note that in some rare cases the [192]-notruecolor option has
   corrected colors on 8bpp displays. The red, green, and blue masks were
   non-zero in 8bpp PseudoColor on an obscure setup, and this option
   corrected the problems.


   Q-15: Color problems: Why are the colors for some windows messed up in
   x11vnc? BTW, my X display has nice overlay/multi-depth visuals of
   different color depths: e.g. there are both depth 8 and 24 visuals
   available at the same time.

   You may want to review the [193]previous question regarding 8 bpp
   PseudoColor.

   On some hardware (Sun/SPARC, Sgi), the [194]-overlay option discussed
   a couple paragraphs down may solve this for you (you may want to skip
   to it directly).

   Run xdpyinfo(1) to see what the default visual is and what the depths
   of the other visuals are. Does the default visual have a depth of 8?
   If it does, can you possibly re-configure your X server to make the
   depth 24 visual the default? If you can do it, this will save you a
   lot of grief WRT colors and x11vnc (and for general usage too!). Here
   is how I do this on an old Sparcstation 20 running Solaris 9 with SX
   graphics
  xinit -- -dev /dev/fb defclass TrueColor defdepth 24

   and it works nicely (note: to log into console from the dtlogin
   window, select "Options -> Command Line Login", then login and enter
   the above command). See the -dev section of the Xsun(1) manpage for a
   description of the above arguments. If you have root permission, a
   more permanent and convenient thing to do is to record the arguments
   in a line like:
  :0  Local local_uid@console root /usr/openwin/bin/Xsun -dev /dev/fb defclass
TrueColor defdepth 24

   in /etc/dt/config/Xservers (copy /usr/dt/config/Xservers). Also look
   at the fbconfig(1) and related manpages (e.g. ffbconfig, m64config,
   pgxconfig, SUNWjfb_config, etc ...) for hardware framebuffer settings
   that may achieve the same effect.

   In general for non-Sun machines, look at the "-cc class" and related
   options in your X server manpage (perhaps Xserver(1)), it may allow
   modifying the default visual (e.g. "-cc 4", see <X11/X.h> for the
   visual class numbers). On XFree86 some video card drivers (e.g. Matrox
   mga) have settings like Option "Overlay" "24,8" to support multi-depth
   overlays. For these, use the "-cc 4" X server command line option to
   get a depth 24 default visual.


   The -overlay mode: Another option is if the system with overlay
   visuals is a Sun system running Solaris or Sgi running IRIX you can
   use the [195]-overlay x11vnc option (Aug/2004) to have x11vnc use the
   Solaris XReadScreen(3X11) function to poll the "true view" of the
   whole screen at depth 24 TrueColor. XReadDisplay(3X11) is used on
   IRIX. This is useful for Legacy applications (older versions of
   Cadence CAD apps are mentioned by x11vnc users) that require the
   default depth be 8bpp, or the app will use a 8bpp visual even if depth
   24 visuals are available, and so the default depth workaround
   described in the previous paragraph is not sufficient for these apps.

   Misc. notes on -overlay mode: An amusing by-product of -overlay mode
   is that mouse cursor shape is correct. The -overlay mode may be
   somewhat slower than normal mode due to the extra framebuffer
   manipulations that must be performed. Also, on Solaris there is a bug
   in that for some popup menus, the windows they overlap will have
   painting errors (flashing colors) while the popup is up (a workaround
   is to disable SaveUnders by passing -su to Xsun, e.g. in your
   /etc/dt/config/Xservers file).


   Colors still not working correctly? Run xwininfo on the application
   with the messed up colors to verify that the depth of its visual is
   different from the default visual depth (gotten from xdpyinfo). One
   possible workaround in this case is to use the [196]-id option to
   point x11vnc at the application window itself. If the application is
   complicated (lots of toplevel windows and popup menus) this may not be
   acceptable, and may even crash x11vnc (but not the application).

   It is theoretically possible to solve this problem in general (see
   xwd(1) for example), but it does not seem trivial or sufficiently fast
   for x11vnc to be able to do so in real time. Fortunately the
   [197]-overlay option works for Solaris machines with overlay visuals
   where most of this problem occurs.


   Q-16: How do I figure out the window id to supply to the -id windowid
   option?

   Run the xwininfo program in a terminal. It will ask you to click on
   the desired application window. After clicking, it will print out much
   information, including the window id (e.g. 0x6000010). Also, the
   visual and depth of the window printed out is often useful in
   debugging x11vnc [198]problems.

   When using -id windowid, note that some VNC viewers will have problems
   rendering screens that have a width that is not a multiple of 4. Try
   to manually adjust the window width before starting x11vnc -id ....

   Also, as of Dec/2004 libvncserver CVS you can use "[199]-id pick" to
   have x11vnc run xwininfo(1) for you and after you click the window it
   extracts the windowid. Besides "pick" there is also "id:root" to allow
   you to go back to root window when doing remote-control.


   Q-17: Why don't menus or other transient windows come up when I am
   using the -id windowid option to view a single application window?

   This is related to the behavior of the XGetImage(3X11) and
   XShmGetImage() interfaces regarding backingstore, saveunders, etc. The
   way the image is retrieved depends on some aspects of how the X server
   maintains the display image data and whether other windows are
   clipping or obscuring it. See the XGetImage man page for more details.
   If you disable BackingStore and SaveUnders in the X server you should
   be able to see these transient windows.

   If things are not working and you still want to do the single window
   polling, try the [200]-sid windowid option ("shifted" windowid).

   x11vnc is known to crash under both -id and -sid, so both modes are
   still experimental. Please report any reproducible bugs.


   Q-18: My X display is depth 24 at 24bpp (instead of the normal depth
   24 at 32bpp). I'm having lots of color and visual problems with x11vnc
   and/or vncviewer. What's up?

   First off, depth 24 at 24bpp (bpp=bits-per-pixel) is fairly uncommon
   and can cause problems in general. It also can be slower than depth 24
   at 32bpp. You might want to switch to 32bpp (for XFree86 see the
   "-fbbpp 32", DefaultFbBpp, FbBpp and related options). Perhaps you
   have 24bpp because the video memory of the machine is low and the
   screen wouldn't fit in video RAM at 32bpp. For this case depth 16 at
   16bpp might be an acceptable option.

   In any event x11vnc should handle depth 24 at 24bpp (although
   performance may be slower). There are some caveats involving the
   viewer however:

   The RealVNC Unix viewer cannot handle 24bpp from the server, it will
   say: "main: setPF: not 8, 16 or 32 bpp?" and exit. I have not checked
   the RealVNC Windows viewer.

   So you need to use the TightVNC Unix viewer. However there are some
   problems with that too. It seems libvncserver does not do 24bpp
   correctly with the Tight encoding. The colors and screen ultimately
   get messed up. So you have to use a different encoding with the
   TightVNC vncviewer, try "zlib", "hextile", or one of the other
   encodings (e.g. vncviewer -encodings "zlib hextile" ...). I have not
   checked the TightVNC or UltraVNC Windows viewers.

   It appears the older RealVNC Unix viewers (e.g. 3.3.3 and 3.3.7) can
   handle 24bpp from the server, so you may want to use those. They
   evidently request 32 bpp and libvncserver obliges.

   Now coming the opposite direction if you are running the vncviewer on
   the 24bpp display, TightVNC will fail with "Can't cope with 24
   bits-per-pixel. Sorry." and RealVNC will fail with "main: Error:
   couldn't find suitable pixmap format" so evidently you cannot use
   24bpp for the vncviewers to work on that X display.
   [Xterminals]

   Q-19: Can I use x11vnc to view and interact with an Xterminal (e.g.
   NCD) that is not running UNIX and so x11vnc cannot be run on it
   directly?

   You can, but it will likely be very wasteful of network bandwidth
   since you will be polling the X display over the network as opposed to
   over the local hardware. To do this, run x11vnc on a UNIX machine as
   close as possible network-wise (e.g. same switch) to the Xterminal
   machine. Use the [201]-display option to point the display to that of
   the Xterminal (you'll of course need basic X11 permission to do that)
   and also supply the [202]-noshm option (this enables the polling over
   the network).

   The response will likely be sluggish (maybe only one "frame" per
   second). This mode is not recommended except for "quick checks" of
   hard to get to X servers. Use something like -wait 150 to cut down on
   the polling rate. You may also need [203]-flipbyteorder if the colors
   get messed up due to endian byte order differences.

   Q-20: How do I get my X permissions (MIT-MAGIC-COOKIE) correct for a
   Unix/Linux machine acting as an Xterminal?

   If the X display machine is a traditional Xterminal (where the X
   server process runs on the Xterminal box, but all of the X client
   applications (mozilla, etc) run on a central server (aka "terminal
   server")), you will need to log into the Xterminal machine (i.e. get a
   shell running there) and then start the x11vnc program. If the
   Xterminal Linux/Unix machine is stripped down (e.g. no users besides
   root) that may be difficult.

   The next problem is the login Display Manager (e.g. gdm, kdm), and
   hence the MIT-MAGIC-COOKIE auth files, are on the central server and
   not on the Xterminal box where the X server and x11vnc processes are.

   So unless X permissions are completely turned off (e.g. "xhost +"), to
   run the x11vnc process on the Xterminal box the MIT-MAGIC-COOKIE auth
   file data (XAUTHORITY or $HOME/.Xauthority) must be accessible by or
   copied to the Xterminal. If $HOME/.Xauthority is exported via NFS
   (this is insecure of course, but has been going on for decades), then
   x11vnc can simply pick it up via NFS (you may need to use the
   [204]-auth option to point to the correct file). Other options include
   copying the auth file using scp, or something like:
  central-server>  xauth nextract - xterm123:0 | ssh xterm123 xauth nmerge -

   and then, say, ssh from central-server to xterm123 to start x11vnc.
   Here "xterm123" refers to the computer acting as the Xterminal and
   "central-server" is the terminal server. You can use "xauth -f
   /path/to/cookie-file list" to examine the contents of the cookie(s) in
   a file "/path/to/cookie-file". See the xauth(1) manpage for more
   details.

   If the display name in the cookie file needs to be changed between the
   two hosts, see [205]this note on the "xauth add ..." command.

   A less secure option is to run something like "xhost +127.0.0.1" while
   sitting at the Xterminal box to allow cookie-free local access for
   x11vnc. You can run "xhost -127.0.0.1" after x11vnc connects if you
   want to go back to the original permissions.

   If the Xterminal is really stripped down and doesn't have any user
   accounts, NFS, etc. you'll need to contact your system administrator
   to set something up. It can be done!!!  Some Xterminal projects have
   actually enabled "run locally" facilities for the running of an
   occasional app more efficiently locally on the Xterminal box (e.g.
   realplayer).

   Not recommended, but as a last resort, you could have x11vnc [206]poll
   the Xterminal Display over the network. For this you would run a
   "x11vnc -noshm ..." process on the central-server (and hope the
   network admin doesn't get angry...)

   Note: use of Display Manager (gdm, kdm, ...) auth cookie files (i.e.
   from /var/...,  /tmp/..., or elsewhere) may require modification via
   xauth(1) to correctly include the display x11vnc refers to (e.g.
   "xauth -f cookie-file add :0 . 45be51ae2ce9dfbacd882ab3ef8e96b1",
   where the "45be51..." cookie value was found from an "xauth -f
   /path/to/original/cookie-file list") or other reasons. See xauth(1)
   manpage for full details on how to transfer an MIT-MAGIC-COOKIE
   between machines and displays.

   VNCviewer performance on Xterminals:  This isn't related to x11vnc on
   Xterminals, but we mention it here anyway because of the similar
   issues. If you are on an Xterminal and want to use vncviewer to
   connect to a VNC server somewhere, then performance would be best if
   you ran the viewer on the Xterminal box. Otherwise, (i.e. running the
   viewer process on the central-server) all of the vncviewer screen
   drawing is done more inefficiently over the network. Something to
   consider, especially on a busy network. (BTW, this has all of the
   above permission, etc, problems: both vncviewer and x11vnc are X
   client apps desired to be run on the Xterminal box).

   [Remote Control]

   Q-21: How do I stop x11vnc once it is running in the background?

   As of Dec/2004 in the libvncserver CVS there is a remote control
   feature. It can change a huge amount of things on the fly: see the
   [207]-remote and [208]-query options. To shut down the running x11vnc
   server just type "x11vnc -R stop". To disconnect all clients do
   "x11vnc -R disconnect:all", etc.

   For older versions: If the [209]-forever option has not been supplied,
   x11vnc will automatically exit after the first client disconnects. In
   general you will have to kill the x11vnc process This can be done via:
   "kill NNNNN" (where NNNNN is the x11vnc process id number found from
   ps(1)), or "pkill x11vnc", or "killall x11vnc" (Linux only).

   If you have not put x11vnc in the background via the [210]-bg option
   or shell & operator, then simply press Ctrl-C in the shell where
   x11vnc is running to stop it. Potential Gotcha: If somehow your
   Keypress of Ctrl-C went through x11vnc to the Xserver that then
   delivered it to x11vnc it is possible one or both of the Ctrl or C
   keys will be left stuck in the pressed down state in the Xserver.
   Tapping the stuck key (either via a new x11vnc or at the physical
   console) will release it from the stuck state. If the keyboard seems
   to be acting strangely it is often fixed by tapping Ctrl, Shift, and
   Alt. Alternatively, the [211]-clear_mods option and [212]-clear_keys
   option can be used to release pressed keys at startup and exit.


   Q-22: Can I change settings in x11vnc without having to restart it?
   Can I remote control it?

   Look at the [213]-remote (same as -R) and [214]-query (same as -Q)
   options added in the Dec/2004 libvncserver CVS. They allow nearly
   everything to be changed dynamically and settings to be queried.
   Examples: "x11vnc -R shared", "x11vnc -R forever", "x11vnc -R
   scale:3/4", "x11vnc -Q modtweak", "x11vnc -R stop", "x11vnc -R
   disconnect:all", etc.. These commands do not start a x11vnc server,
   but rather communicate with one that is already running. The X display
   (VNC_CONNECT property) is used as the communication channel, so the X
   permissions and DISPLAY must be set up correctly for communication to
   be possible.

   There is also a simple tcl/tk gui based on this remote control
   mechanism. See the [215]-gui option for more info.

   [Security and Permissions]

   Q-23: How do I create a VNC password for use with x11vnc?

   You may already have one in $HOME/.vnc/passwd if you have used, say,
   the vncserver program from the regular RealVNC or TightVNC packages
   (i.e. launching the Xvnc server). Otherwise, you could use the
   vncpasswd(1) program from those packages. The libvncserver package
   also comes with a simple program: storepasswd in the examples
   directory. And as of Jun/2004 in the libvncserver CVS x11vnc supports
   the -storepasswd "pass" "file" [216]option, which is the the same
   functionality of storepasswd. Be sure to quote the "pass" if it
   contains shell meta characters, spaces, etc. Example:
  x11vnc -storepasswd 'sword*fish' $HOME/myvncpasswd

   You then use the password via the x11vnc option: [217]-rfbauth
   $HOME/myvncpasswd

   Compared to vncpasswd(1) the latter two methods are a somewhat unsafe
   because the password is specified on the command line and so someone
   may see it by using ps(1) or looking over your shoulder. Also watch
   out for the command winding up in your shell's history file (history
   -c is often a way to clear it).

   x11vnc also has the [218]-passwdfile and -passwd/-viewpasswd plain
   text (i.e. not obscured like the -rfbauth VNC passwords) password
   options.


   Q-24: Can I have two passwords for VNC viewers, one for full access
   and the other for view-only access to the display?

   Yes, as of May/2004 in the libvncserver CVS there is the
   [219]-viewpasswd option to supply the view-only password. Note the
   full-access password option [220]-passwd must be supplied at the same
   time. E.g.: -passwd sword -viewpasswd fish.

   To avoid specifying the passwords on the command line (where they
   could be observed via the ps(1) command by any user) you can use the
   [221]-passwdfile option to specify a file containing plain text
   passwords. Presumably this file is readable only by you, and ideally
   it is located on the machine x11vnc is run on (to avoid being snooped
   on over the network). The first line of this file is the full-access
   password. If there is a second line in the file and it is non-blank,
   it is taken as the view-only password. (use "__EMPTY__" to supply an
   empty one).

   View-only passwords currently do not work for the [222]-rfbauth
   password option (standard VNC password storing mechanism). FWIW, note
   that although the output (usually placed in $HOME/.vnc/passwd) by the
   vncpasswd or storepasswd programs (or from x11vnc -storepasswd) looks
   encrypted they are really just obscured to avoid "casual" password
   stealing. It takes almost no skill to figure out how to extract the
   plain text passwords from $HOME/.vnc/passwd since it is very
   straight-forward to work out what to do from the VNC source code.


   Q-25: Can I fine tune what types of user input are allowed? E.g. have
   some users just be able to move the mouse, but not click or type
   anything?

   As of Feb/2005, the [223]-input option allows you to do this. "K",
   "M", and "B" stand for Keystroke, Mouse-motion, and Button-clicks,
   respectively. The setting: "-input M" makes attached viewers only able
   to move the mouse. "-input KMB,M" lets normal clients do everything
   and enables view-only clients to move the mouse.

   These settings can also be applied on a per-viewer basis via the
   remote control mechanism or the GUI. E.g. x11vnc -R input:hostname:M


   Q-26: Why does x11vnc exit as soon as the VNC viewer disconnects? And
   why doesn't it allow more than one VNC viewer to connect at the same
   time?

   These defaults are simple safety measures to avoid someone unknowingly
   leaving his X11 desktop exposed (to the internet, say) for long
   periods of time. Use the [224]-forever option (aka -many) to have
   x11vnc wait for more connections after the first client disconnects.
   Use the [225]-shared option to have x11vnc allow multiple clients to
   connect simultaneously.

   Recommended additional safety measures include using ssh ([226]see
   above), stunnel, or a VPN to authenticate and encrypt the viewer
   connections or to at least use the -rfbauth passwd-file [227]option to
   use VNC password protection (or [228]-passwdfile) It is up to you to
   apply these security measures, they will not be done for you
   automatically.


   Q-27: Can I limit which machines incoming VNC clients can connect
   from?

   Yes, look at the [229]-allow and [230]-localhost options to limit
   connections by hostname or IP address. E.g.
  x11vnc -allow 192.168.0.1,192.168.0.2

   for those two hosts or
  x11vnc -allow 192.168.0.

   for a subnet. For individual hosts you can use the hostname instead of
   the IP number, e.g.: "-allow snoopy", and "-allow darkstar,wombat".
   Note that -localhost is the same as "-allow 127.0.0.1"

   For more control, build libvncserver with libwrap support
   [231](tcp_wrappers) and then use /etc/hosts.allow See hosts_access(5)
   for complete details.


   Q-28: How do I build x11vnc/libvncserver with libwrap (tcp_wrappers)
   support?

   Here is one way to pass this information to the configure script:
  env CPPFLAGS=-DUSE_LIBWRAP LDFLAGS=-lwrap ./configure

   then run make as usual. This requires libwrap and its development
   package (tcpd.h) to be installed on the build machine. If additional
   CPPFLAGS or LDFLAGS options are needed supply them as well using
   quotes.

   The resulting x11vnc then uses libwrap/tcp_wrappers for connections.
   The service name you will use in /etc/hosts.allow and /etc/hosts.deny
   is "vnc", e.g.:
  vnc: 192.168.100.3 .example.com

   Note that if you run x11vnc out of [232]inetd you do not need to build
   x11vnc with libwrap support because the /usr/sbin/tcpd reference in
   /etc/inetd.conf handles the tcp_wrappers stuff.


   Q-29: Can I have x11vnc only listen on one network interface (e.g.
   internal LAN) rather than having it listen on all network interfaces
   and relying on -allow to filter unwanted connections out?

   As of Mar/2005 in the libvncserver CVS, there is the "[233]-listen
   ipaddr" option that enables this. For ipaddr either supply the desired
   network interface's IP address (or use a hostname that resolves to it)
   or use the string "localhost". For additional filtering simultaneously
   use the "[234]-allow host1,..." option to allow only specific hosts
   in.

   This option is useful if you want insure that no one can even begin a
   dialog with x11vnc from untrusted network interfaces (e.g. ppp0). The
   option [235]-localhost now implies "-listen localhost" since that is
   what most people expect it to do.


   Q-30: Now that -localhost implies listening only on the loopback
   interface, how I can occasionally allow in a non-localhost via the
   allowonce remote control command?

   To do this specify "[236]-allow localhost". Unlike [237]-localhost
   this will leave x11vnc listening on all interfaces (but of course only
   allowing in local connections, e.g. ssh redirs). Then you can later
   run "x11vnc -R allowonce:somehost" or use to gui to permit a one-shot
   connection from a remote host.

   Note that if you do a lot of changing of the listening interface
   ([238]-listen option) via remote control or gui, you may need to also
   manually adjust the [239]-allow list if you unexpectedly get into a
   state where the allow list cannot match any hosts that would be coming
   in on the listening interface. If you just toggle [240]-localhost on
   and off x11vnc should see to it that you never get into such a state.


   Q-31: How can I tunnel my connection to x11vnc via an encrypted SSH
   channel between two Unix machines?

   See the description earlier on this page on [241]how to tunnel VNC via
   SSH from Unix to Unix. A number of ways are described along with some
   issues you may encounter.

   Other secure encrypted methods exists, e.g. stunnel, IPSEC, various
   VPNs, etc.


   Q-32: How can I tunnel my connection to x11vnc via an encrypted SSH
   channel from Windows using an SSH client like Putty?

   [242]Above we described how to tunnel VNC via SSH from Unix to Unix,
   you may want to review it. To do this from Windows using Putty it
   would go something like this:
     * In the Putty dialog window under 'Session' enter the hostname or
       IP number of the Unix machine with display to be viewed.
     * Make sure the SSH protocol is selected and the server port is
       correct.
     * Under 'Connections/SSH/Tunnels' Add a Local connection with
       'Source port:  5900' and 'Destination:  localhost:5900'
     * Log into the remote machine by pressing 'Open' and supplying
       username, password, etc.
     * In that SSH shell, start up x11vnc by typing the command: x11vnc
       -display :0 plus any other desired options.
     * Finally, start up your VNC Viewer in Windows and enter
       'localhost:0' as the VNC server.

   You can keep all of the settings in a Putty 'Saved Session'. Also,
   once everything is working, you can consider putting x11vnc -display
   :0 (plus other cmdline options) in the 'Remote command' Putty setting
   under 'Connections/SSH'. It is likely possible to script the whole
   process in a BAT file including launching the VNC viewer by using the
   plink Putty utility. Send us the script if you get that working.

   For extra protection feel free to run x11vnc with the [243]-localhost
   and [244]-rfbauth/[245]-passwdfile options.

   If the machine you SSH into via Putty is not the same machine with the
   X display you wish to view (e.g. your company provides incoming SSH
   access to a gateway machine), then you need to change the above Putty
   dialog setting to: 'Destination: otherhost:5900', Once logged in,
   you'll need to do a second login (ssh or rsh) to the workstation
   machine 'otherhost' and then start up x11vnc on it. This can also be
   automated by [246]chaining ssh's.

   As discussed [247]above another option is to first start the VNC
   viewer in "listen" mode, and then launch x11vnc with the
   "[248]-connect localhost" option to establish the reverse connection.
   In this case a Remote port redirection (not Local) is needed for port
   5500 instead of 5900 (i.e. 'Source port:  5500' and
   'Destination:  localhost:5500' for a Remote connection).


   Q-33: Can I prompt the user at the local X display whether the
   incoming VNC client should be accepted or not? Can I decide to make
   some clients view-only? How about running an arbitrary program to make
   the decisions?

   Yes, look at the "[249]-accept command" option, it allows you to
   specify an external command that is run for each new client. (use
   quotes around the command if it contains spaces, etc.). If the
   external command returns 0 the client is accepted, otherwise the
   client is rejected. See below how to also accept clients view-only.

   The external command will have the RFB_CLIENT_IP environment variable
   set to the client's numerical IP address, RFB_CLIENT_PORT its port
   number. Similarly for RFB_SERVER_IP and RFB_SERVER_PORT to allow
   identification of the tcp virtual circuit. DISPLAY will be set to that
   of the X11 display being polled. Also, RFB_X11VNC_PID is set to the
   x11vnc process id (e.g. in case you decided to kill it), RFB_CLIENT_ID
   will be an id number, and RFB_CLIENT_COUNT the number of other clients
   currently connected. RFB_MODE will be "accept".

   As a special case, "-accept popup" will instruct x11vnc to create its
   own simple popup window. To accept the client press "y" or click mouse
   on the "Yes" button. To reject the client press "n" or click mouse on
   the "No" button. To accept the client View-only, press "v" or click
   mouse on the "View" button. If the [250]-viewonly option has been
   supplied, the "View" action will not be present: the whole display is
   view only in that case.

   The popup window times out after 120 seconds, to change this behavior
   use "-accept popup:N" where N is the number of seconds (use 0 for no
   timeout). More tricks: "-accept popupmouse" will only take mouse click
   responses, while "-accept popupkey" will only take keystroke responses
   (popup takes both). After any of the 3 popup keywords you can supply a
   position of the window: +N+M, (the default is to center the window)
   e.g. -accept popupmouse+10+10.

   Also as a special case "-accept xmessage" will run the xmessage(1)
   program to prompt the user whether the client should be accepted or
   not. This requires that you have xmessage installed and available via
   PATH. In case it is not already on your system, the xmessage program
   is available at [251]ftp://ftp.x.org/

   To include view-only decisions for the external commands, prefix the
   command something like this: "yes:0,no:*,view:3 mycommand ..." This
   associates the three actions: yes(accept), no(reject), and
   view(accept-view-only), with the numerical return codes. Use "*"
   instead of a number to set the default action (e.g. in case the
   external command returns an unexpected return code).

   Here is an example -accept script called accept_or_lock. It uses
   xmessage and xlock (replace with your screen lock command, maybe it is
   "xscreensaver-command -lock", or kdesktop_lock, or "dtaction
   LockDisplay"). It will prompt the user at the X display whether to
   accept, reject, or accept view-only the client, but if the prompt
   times out after 60 seconds the screen is locked and the VNC client is
   accepted. This allows the remote access when no one is at the display.
#!/bin/sh
#
# accept_or_lock: prompt user at X display whether to accept an incoming
#                 VNC connection.  If timeout expires, screen is locked
#                 and the VNC viewer is accepted (allows remote access
#                 when no one is sitting at the display).
#
# usage: x11vnc ... -forever -accept 'yes:0,no:*,view:4 accept_or_lock'
#
xmessage -buttons yes:2,no:3,view-only:4 -center \
         -timeout 60 "x11vnc: accept connection from $RFB_CLIENT_IP?"
rc=$?
if [ $rc = 0 ]; then
        xlock &
        sleep 5
        exit 0
elif [ $rc = 2 ]; then
        exit 0
elif [ $rc = 4 ]; then
        exit 4
fi
exit 1

   Stefan Radman has written a nice dtksh script [252]dtVncPopup for use
   in CDE environments to do the same sort of thing. Information on how
   to use it is found at the top of the file. He encourages you to
   provide feedback to him to help improve the script.

   Note that in all cases x11vnc will block while the external command or
   popup is being run, so attached clients will not receive screen
   updates, etc during this period.

   To run a command when a client disconnects, use the "[253]-gone
   command" option. This is for the user's convenience only: the return
   code of the command is not interpreted by x11vnc. The same environment
   variables are set as in "-accept command" (except that RFB_MODE will
   be "gone").


   Q-34: Does x11vnc support Unix usernames and passwords? Can I further
   limit the set of Unix usernames who can connect to the VNC desktop?

   Until the VNC protocol and libvncserver support this things will be
   approximate at best. Hopefully, it will not be too long to wait for
   such support.

   One approximate method involves starting x11vnc with the
   [254]-localhost option. This basically requires the viewer user to log
   into the workstation where x11vnc is running via their Unix username
   and password, and then somehow set up a port redirection of his
   vncviewer connection to make it appear to emanate from the local
   machine. As discussed above, ssh is useful for this: ssh -l username
   -L 5900:localhost:5900 hostname ... See the ssh wrapper scripts
   mentioned [255]elsewhere on this page. Of course a malicious user
   could allow other users to get in through his channel, but that is a
   problem with every method. Another thing to watch out for is a
   malicious user on the viewer side (where ssh is running) trying to
   sneak in through the ssh port redirection.

   Regarding limiting the set of Unix usernames who can connect, the
   traditional way would be to further require a VNC password to supplied
   (-rfbauth, -passwd, etc). A scheme that avoids a second password
   involves using the [256]-accept option that runs a program to examine
   the connection information to determine which user is connecting from
   the local machine. For example, the program could use the ident
   service on the local machine (normally ident should not be trusted
   over the network, but on the local machine it should be accurate:
   otherwise root has been compromised and so there are more serious
   problems!). An example script passed in via -accept scriptname that
   deduces the Unix username and limits who can be accepted might look
   something like this:
#!/bin/sh
if [ "$RFB_CLIENT_IP" != "127.0.0.1" -o "$RFB_SERVER_IP" != "127.0.0.1" ]; then
        exit 1  # something fishy... reject it.
fi
user=`echo "$RFB_CLIENT_PORT, $RFB_SERVER_PORT" | nc -w 1 $RFB_CLIENT_IP 113 \
        | grep 'USERID.*UNIX' | head -1 | sed -e 's/[\r ]//g' | awk -F: '{print
 $4}'`

for okuser in fred barney wilma betty
do
        if [ "X$user" = "X$okuser" ]; then
                exit 0  # accept it
        fi
done
exit 1  # reject it

   For this to work with ssh port redirection, the ssh option
   UsePrivilegeSeparation must be enabled.


   Q-35: I start x11vnc as root because it is launched via inetd(1) or a
   display manager like gdm(1). Can I have x11vnc later switch to a
   different user?

   As of Feb/2005 x11vnc has the [257]-users option that allows things
   like this. Please read the documentation on it (in the x11vnc -help
   output) carefully for features and caveats. It's use can often
   decrease security unless care is taken. A nice use of it is "-users
   +nobody" that switches to the Unix user nobody right after connections
   to the X display are established.


   Q-36: I use a screen-lock when I leave my workstation (e.g.
   xscreensaver or xlock). When I remotely access my workstation desktop
   via x11vnc I can unlock the desktop fine, but I am worried people will
   see my activities on the physical monitor. What can I do to prevent
   this, or at least make it more difficult?

   Probably most work environments would respect your privacy if you
   powered off the monitor. Also remember if people have physical access
   to your workstation they basically can do anything they want with it
   (e.g. install a backdoor for later use, etc).

   In any event, as of Jun/2004 there is an experimental utility to make
   it more difficult for nosey people to see your x11vnc activities. The
   source for it is [258]blockdpy.c The idea behind it is simple (but
   obviously not bulletproof): when a VNC client attaches to x11vnc put
   the display monitor in the DPMS "off" state, if the DPMS state ever
   changes immediately start up the screen-lock program. The x11vnc user
   will notice something is happening and think about what to do next
   (while the screen is in a locked state).

   This works (or at least has a chance of working) because if the
   intruder moves the mouse or presses a key on the keyboard, the monitor
   wakes up out of the DPMS off state, and this induces the screen lock
   program to activate as soon as possible. Of course there are cracks in
   this, the eavesdropper could detach your monitor and insert a non-DPMS
   one, and there are race conditions. As mentioned above this is not
   bulletproof. A really robust solution would likely require X server
   and perhaps even video hardware support.

   The blockdpy utility is launched by the [259]-accept option and told
   to exit via the [260]-gone option (the vnc client user should
   obviously re-lock the screen before disconnecting!). Instructions can
   be found in the source code for the utility at the above link.


   Q-37: Can I have x11vnc automatically lock the screen when I
   disconnect the VNC viewer?

   Yes, a user mentions he uses the [261]-gone option under CDE to run a
   screen lock program:
  x11vnc -display :0 -forever -gone 'dtaction LockDisplay'

   Other possibilities are:
  x11vnc -display :0 -forever -gone 'xscreensaver-command -lock'
  x11vnc -display :0 -forever -gone 'kdesktop_lock'
  x11vnc -display :0 -forever -gone 'xlock &'


   [Display Managers and Services]

   Q-38: How can I run x11vnc as a "service" that is always available?

   There are a number of ways to do this. The primary thing you need to
   decide is whether you want x11vnc to connect to the X session on the
   machine 1) regardless of who (or if anyone) has the X session, or 2)
   only if a certain user has the X session. Because X sessions are
   protected by X permissions (XAUTHORITY and $HOME/.Xauthority) the
   automatically started x11vnc will of course need to have sufficient
   permissions to connect to the X display.

   Here are some ideas:
     * Use the description under "Continuously" in the [262]FAQ on x11vnc
       and Display Managers
     * Use the description in the [263]FAQ on x11vnc and inetd(1)
     * Start x11vnc from your $HOME/.xsession (or $HOME/.xinitrc)
     * Although less reliable, see the [264]x11vnc_loop rc.local hack
       below.

   The display manager scheme will not be specific to which user has the
   X session unless a test is specifically put into the display startup
   script (often named Xsetup). The inetd(1) scheme may or may not be
   specific to which user has the X session (and it may not be able to do
   all users via the XAUTHORITY permission issues).

   The $HOME/.xsession scheme is obviously is specific to a particular
   user. If you do not know what a $HOME/.xsession script is or how to
   use one, perhaps your desktop has a "session startup commands"
   configuration option. The command to be run in the .xsession or
   .xinitrc file may look like this:
x11vnc -logfile $HOME/.x11vnc.log -rfbauth $HOME/.vnc/passwd -forever -bg

   plus any other options you desire.


   Q-39: How can I use x11vnc to connect to an X login screen like xdm,
   GNOME gdm, KDE kdm, or CDE dtlogin? (i.e. nobody is logged into an X
   session yet).

   One time only.   If the X login screen is running and you just want to
   connect to it once (i.e. a one-shot):

   It is usually possible to do this by just adjusting the XAUTHORITY
   environment variable to point to the correct MIT-COOKIE auth file
   while running x11vnc as root, e.g. for the gnome display manager, gdm:
  x11vnc -auth /var/gdm/:0.Xauth -display :0

   (the [265]-auth option sets the XAUTHORITY variable for you).

   There will be a similar thing for xdm using however a different auth
   directory path (perhaps something like
   /var/lib/xdm/authdir/authfiles/A:0-XQvaJk for xdm or
   /var/lib/kdm/A:0-crWk72 for kdm, where the random characters in
   basename will vary a bit). Read your system docs to find out where the
   display manager cookie files are kept.

   Trick: sometimes ps(1) can reveal the X server process -auth argument
   (e.g. "ps wwwwaux | grep auth").

   You next connect to x11vnc with a VNC viewer, give your username and
   password to the X login prompt to start your session.

   Note:  gdm seems to have an annoying setting that causes x11vnc (and
   any other X clients) to be killed after the user logs in. Setting
   KillInitClients=false in the [daemon] section of /etc/X11/gdm/gdm.conf
   avoids this. Otherwise, just restart x11vnc and then reconnect your
   viewer.

   Note:  For dtlogin in addition to the above sort of trick (BTW, the
   auth file should be in /var/dt), you'll also need to add something
   like Dtlogin*grabServer:False to the Xconfig file
   (/etc/dt/config/Xconfig or /usr/dt/config/Xconfig on Solaris, see
   [266]the example at the end of this FAQ). Then restart dtlogin, e.g.:
   /etc/init.d/dtlogin stop; /etc/init.d/dtlogin start or reboot.

   Continuously.   Have x11vnc reattach each time the X server is
   restarted (i.e. after each logout):

   To make x11vnc always attached to the the X server (please consider
   the security implications of this!) including the login screen you
   will need to add a command to a display manager startup script. The
   name of the script file depends on desktop used and seem to be:
        GNOME        /etc/X11/gdm/Init/Default  (or Init/:0)
        KDE          /etc/kde*/kdm/Xsetup
        XDM          /etc/X11/xdm/Xsetup        (or xdm/Xsetup_0)
        CDE          /etc/dt/config/Xsetup

   although the exact location can depend on operating system and
   distribution. See the documentation for your display manager:  gdm(1),
   kdm(1), xdm(1), dtlogin(1) for additional details. There may also be
   display number specific scripts: e.g. Xsetup_0 vs. Xsetup, you need to
   watch out for.

   Note:  The above gdm setting of KillInitClients=false in
   /etc/X11/gdm/gdm.conf is needed here as well.

   Note:  The above Dtlogin*grabServer:False step will be needed for
   dtlogin here as well.

   In any event, the line you will add to the display manager script will
   look something like:
  /usr/local/bin/x11vnc -rfbauth /path/to/the/vnc/passwd -o /tmp/x11vnc.log -fo
rever -bg

   where you should customize the exact command to your needs.

   Happy, happy, joy, joy:  Note that we do not need to specify -display
   or -auth because happily they are already set for us in the DISPLAY
   and XAUTHORITY environment variables for the Xsetup script!!!

   You may also want to force the VNC port with something like "-rfbport
   5900"
     _________________________________________________________________

   Fedora/gdm: Here is an example of what we did on a vanilla install of
   Fedora-C3 (seems to use gdm by default). Add a line like this to
   /etc/X11/gdm/Init/:0
  /usr/local/bin/x11vnc -rfbauth /etc/x11vnc.passwd -forever -bg -o /tmp/x11vnc
.log

   And then add this line to /etc/X11/gdm/gdm.conf in the [daemon]
   section:
  KillInitClients=false

   Then restart: /usr/sbin/gdm-restart (or reboot). The
   KillInitClients=false setting is important: without it x11vnc will be
   killed immediately after the user logs in. Here are [267]full details
   on how to configure gdm
     _________________________________________________________________

   Solaris/dtlogin: Here is an example of what we did on a vanilla
   install of Solaris:
   Make the directory /etc/dt/config:
  mkdir -p /etc/dt/config

   Copy over the Xconfig file for customization:
  cp /usr/dt/config/Xconfig /etc/dt/config/Xconfig

   Edit /etc/dt/config/Xconfig and uncomment the line:
  Dtlogin*grabServer:        False

   Next, copy over Xsetup for customization:
  cp /usr/dt/config/Xsetup /etc/dt/config/Xsetup

   Edit /etc/dt/config/Xsetup and at the bottom put a line like:
  /usr/local/bin/x11vnc -forever -o /var/tmp/x11vnc.log -bg

   (tweaked to your local setup and preferences, a password via -rfbauth,
   etc. would be a very good idea).

   Restart the X server and dtlogin:
  /etc/init.d/dtlogin stop
  /etc/init.d/dtlogin start

   (or reboot or maybe just restart the X session).
     _________________________________________________________________

   KDM: One user running the kdm display manager reports putting this
   line:
  x11vnc -forever -rfbauth /home/xyz/.vnc/passwd -bg -o /tmp/x11vnc.log

   in /etc/kde/kdm/Xsetup. After rebooting the system it all seemed to
   work fine.
     _________________________________________________________________


   If you do not want to deal with any display manager startup scripts,
   here is a kludgey script that can be run manually or out of a boot
   file like rc.local: [268]x11vnc_loop It will need some local
   customization before running. Because the XAUTHORITY auth file must be
   guessed by this script, use of the display manager script method
   described above is greatly preferred.

   If the machine is a traditional Xterminal you may want to read
   [269]this FAQ.


   Q-40: Can I run x11vnc out of inetd(1)? How about xinetd(1)?

   Yes, perhaps a line something like this in /etc/inetd.conf will do it
   for you:

  5900 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_sh

   where the shell script /usr/local/bin/x11vnc_sh uses the [270]-inetd
   option and looks something like (you'll need to customize to your
   settings).
#!/bin/sh
/usr/local/bin/x11vnc -inetd -display :0 -auth /home/fred/.Xauthority \
        -rfbauth /home/fred/.vnc/passwd -o /tmp/x11vnc_sh.log

   Important:  Note that you must redirect the standard error output to a
   log file (e.g. -o logfile) or "2>/dev/null" for proper operation via
   inetd (otherwise the standard error also goes to the VNC vncviewer,
   and that confuses it greatly, causing it to abort). If you do not use
   a wrapper script as above but rather call x11vnc directly in
   /etc/inetd.conf and do not redirect stderr to a file, then you must
   specify the -q (aka [271]-quiet) option: "/usr/local/bin/x11vnc -q
   -inetd ...". When you supply both -q and -inet and no "-o logfile"
   then stderr will automatically be closed (to prevent, e.g. library
   stderr messages leaking out to the viewer). The recommended practice
   is to use "-o logfile" to collect the output in a file or wrapper
   script with "2>logfile" redirection because the errors and warnings
   printed out are very useful in troubleshooting problems.

   Note also the need to set XAUTHORITY via [272]-auth to point to the
   MIT-COOKIE auth file to get permission to connect to the X display
   (setting and exporting the XAUTHORITY variable accomplishes the same
   thing). See the x11vnc_loop file in the previous question for more
   ideas on what that auth file may be, etc.

   Note:  On Solaris you cannot have the bare number 5900 in
   /etc/inetd.conf, you'll need to replace it with a word like x11vnc an
   then put something like "x11vnc 5900/tcp" in /etc/services.

   Since the process runs as root, it might be a bad idea to have the
   logfile in a world-writable area like /tmp if there are untrustworthy
   users on the machine. Perhaps /var/log would be a better place.

   Be sure to look at your /etc/hosts.allow and /etc/hosts.deny settings
   to limit the machines that can connect to this service (your
   desktop!). For the above example with /etc/hosts.allow:
  x11vnc_sh : 123.45.67.89

   A really safe way to do things is to limit the above inetd to
   localhost only (via /etc/hosts.allow) and use ssh to tunnel the
   incoming connection. Using inetd for this prevents there being a tiny
   window of opportunity between x11vnc starting up and your vncviewer
   connecting to it. Always use a VNC password to further protect against
   unwanted access.

   For xinetd(1), one user reports he created the file
   /etc/xinetd.d/x11vncservice containing the following:
# default: off
# description:
service x11vncservice
{
        flags           = REUSE NAMEINARGS
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/sbin/tcpd
        server_args     = /usr/local/bin/x11vnc_sh
        disable         = no
}

   With the contents of /usr/local/bin/x11vnc_sh similar to the example
   given above. One user reports this works with avoiding the wrapper
   script:
service x11vncservice
{
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/local/bin/x11vnc
        server_args     = -inetd -q -display :0 -auth /var/gdm/:0.Xauth
        disable         = no
}

   (or one can replace the -q with say "-o /var/log/x11vnc.log" to
   capture a log)


   Q-41: How do I make x11vnc work with the Java VNC viewer applet in a
   web browser?

   To have x11vnc serve up a Java VNC viewer applet to any web browsers
   that connect to it, run x11vnc with this [273]option:
  -httpdir /path/to/the/java/classes/dir

   (this directory will contain the files index.vnc and, for example,
   VncViewer.jar) Note that libvncserver contains the TightVNC Java
   classes jar file for your convenience. (it is the file
   classes/VncViewer.jar in the source tree).

   You will see output something like this:
  14/05/2004 11:13:56 Autoprobing selected port 5900
  14/05/2004 11:13:56 Listening for HTTP connections on TCP port 5800
  14/05/2004 11:13:56   URL http://walnut:5800
  14/05/2004 11:13:56 screen setup finished.
  14/05/2004 11:13:56 The VNC desktop is walnut:0
  PORT=5900

   then you can connect to that URL with any Java enabled browser. Feel
   free to customize the default index.vnc file in the classes directory.

   Note that if you wanted to, you could also start the Java viewer
   entirely from the viewer-side by having the jar file there and using
   either the java or appletviewer commands to run the program.


   Q-42: Are reverse connections (i.e. the VNC server connecting to the
   VNC viewer) using "vncviewer -listen" and vncconnect(1) supported?

   As of Mar/2004 in the libvncserver CVS x11vnc supports reverse
   connections. On Unix one starts the VNC viewer in listen mode:
   vncviewer -listen (see your documentation for Windows, etc), and then
   starts up x11vnc with the [274]-connect option. To connect immediately
   at x11vnc startup time use the "-connect host:port" option (use commas
   for a list of hosts to connect to). The ":port" is optional (default
   is 5500). If a file is specified instead: -connect /path/to/some/file
   then that file is checked periodically (about once a second) for new
   hosts to connect to.

   To use the vncconnect(1) program (from the core VNC package at
   www.realvnc.com) specify the [275]-vncconnect option to x11vnc (Note:
   as of Dec/2004 -vncconnect is now the default). vncconnect(1) must be
   pointed to the same X11 DISPLAY as x11vnc (since it uses X properties
   to communicate with x11vnc). If you do not have or do not want to get
   the vncconnect(1) program, the following script (named "Vncconnect")
   may work if your xprop(1) supports the -set option:
#!/bin/sh
# usage: Vncconnect <host>
#        Vncconnect <host:port>
# note: not all xprop(1) support -set.
#
xprop -root -f VNC_CONNECT 8s -set VNC_CONNECT "$1"


   Q-43: Can I use x11vnc as a replacement for Xvnc? (i.e. not for a real
   display, but for a virtual one I keep around).

   You can, but you would not be doing this for performance reasons (for
   virtual X sessions, Xvnc will give the fastest response). You may want
   to do this because Xvnc does not support an X server extension you
   desire, or you want to take advantage of one of x11vnc's unending
   number of options and features.

   One way to acheive this is to have a Xvfb(1) virtual framebuffer X
   server running in the background and have x11vnc attached to it. One
   could view this desktop both remotely and locally using vncviewer.
   Make sure vncviewer's "-encodings raw" is in effect for local viewing
   (compression seems to slow things down locally).

   Here is one way to start up Xvfb:
  xinit -- /usr/X11R6/bin/Xvfb :1 -screen 0 1024x768x16

   This starts up a 16bpp virtual display. To export it via VNC use
   "x11vnc -display :1 ...".

   One good thing about Xvfb is that the virtual framebuffer exists in
   main memory (rather than in the video hardware), and so x11vnc can
   "screen scrape" it efficiently (more than, say, 100X faster than
   normal video hardware).

   There are some annoyances WRT Xvfb though. The default keyboard
   mapping seems to be very poor. One should run x11vnc with
   [276]-add_keysyms option to have keysyms added automatically. Also, to
   add the Shift_R and Control_R modifiers something like this is needed:
#!/bin/sh
xmodmap -e "keycode any = Shift_R"
xmodmap -e "add Shift = Shift_L Shift_R"
xmodmap -e "keycode any = Control_R"
xmodmap -e "add Control = Control_L Control_R"

   Perhaps the Xvfb options -xkbdb or -xkbmap could be used to get a
   better default keyboard mapping.

   One can use this sort of scheme to export other virtual X sessions,
   say Xnest or even Xvnc itself (useful for testing x11vnc).


   Q-44: How can I use x11vnc on "headless" machines? Why might I want
   to?

   An interesting application of x11vnc is to let it export displays of
   "headless" machines. For example, you may have some lab or server
   machines with no keyboard, mouse, or monitor, but each one still has a
   video card. One can use x11vnc to provide a simple "desktop service"
   from these server machines.

   An X server can be started on the headless machine (sometimes this
   requires configuring the X server to not fail if it cannot detect a
   keyboard or mouse, see the next paragraph). Then you can export that X
   display via x11vnc (e.g. see [277]this FAQ) and access it from
   anywhere on the network via a VNC viewer.

   Some tips on getting X servers to start on machines without keyboard
   or mouse: For XFree86/Xorg the Option "AllowMouseOpenFail" "true"
   "ServerFlags" config file option is useful. On Solaris Xsun the
   +nkeyboard and +nmouse options are useful (put them in the server
   command line args in /etc/dt/config/Xservers). See Xserver(1) for more
   info.

   Although this usage may sound strange it can be quite useful for a GUI
   (or other) testing or QA setups: the engineers do not need to walk to
   lab machines running different hardware, OS's, versions, etc (or have
   many different machines in their office). They just connect to the
   various test machines over the network via VNC. The advantage to
   testing this way instead of using Xvnc or even Xvfb is that the test
   is done using the real X server, fonts, video hardware, etc. that will
   be used in the field.

   One can imagine a single server machine crammed with as many video
   cards as it can hold to provide multiple simultaneous access or
   testing on different kinds of video hardware.

   [Resource Usage and Performance]

   Q-45: I have lots of memory, but why does x11vnc fail with    shmget:
   No space left on device    or    Minor opcode of failed request: 1
   (X_ShmAttach)?

   It is not a matter of free memory, but rather free shared memory (shm)
   slots, also known as shm segments. This often occurs on a public
   Solaris machine using the default of only 100 slots. You (or the owner
   or root) can clean them out with ipcrm(1). x11vnc tries hard to
   release its slots, but it, and other programs, are not always able to
   (e.g. if kill -9'd).

   Sometimes x11vnc will notice the problem with shm segments and tries
   to get by with fewer, only giving a warning like this:
  19/03/2004 10:10:58 shmat(tile_row) failed.
  shmat: Too many open files
  19/03/2004 10:10:58 error creating tile-row shm for len=4
  19/03/2004 10:10:58 reverting to single_copytile mode

   Here is a shell script [278]shm_clear to list and prompt for removal
   of your unattached shm segments (attached ones are skipped). I use it
   while debugging x11vnc (I use "shm_clear -y" to assume "yes" for each
   prompt). If x11vnc is regularly not cleaning up its shm segments,
   please contact me so we can work to improve the situation.

   Longer term, on Solaris you can put something like this in
   /etc/system:
  set shmsys:shminfo_shmmax = 0x2000000
  set shmsys:shminfo_shmmni = 0x1000

   to sweep the problem under the rug (4096 slots). On Linux, examine
   /proc/sys/kernel/shmmni; you can modify the value by writing to that
   file.

   Things are even more tight on Solaris 8 and earlier, there is a
   default maximum number of shm segments per process of 6. The error is
   the X server (not x11vnc) being unable to attach to the segments, and
   looks something like this:
  30/04/2004 14:04:26 Got connection from client 192.168.1.23
  30/04/2004 14:04:26   other clients:
  X Error of failed request:  BadAccess (attempt to access private resource den
ied)
     Major opcode of failed request:  131 (MIT-SHM)
     Minor opcode of failed request:  1 (X_ShmAttach)
     Serial number of failed request:  14
     Current serial number in output stream:  17

   This tight limit on Solaris 8 can be increased via:
  set shmsys:shminfo_shmseg = 100

   in /etc/system. See the next paragraph for more workarounds.

   To minimize the number of shm segments used by x11vnc try using the
   [279]-onetile option (corresponds to only 3 shm segments used, and
   adding -fs 1.0 knocks it down to 2). If you are having much trouble
   with shm segments, consider disabling shm completely via the
   [280]-noshm option. Performance will be somewhat degraded but when
   done over local machine sockets it should be acceptable (see an
   [281]earlier question discussing -noshm).


   Q-46: How can I make x11vnc use less system resources?

   The [282]-nap and "[283]-wait n" (where n is the sleep between polls
   in milliseconds, the default is 30 or so) option are good places to
   start. Reducing the X server bits per pixel depth (e.g. to 16bpp or
   even 8bpp) will further decrease memory I/O and network I/O. Using the
   [284]-onetile option will use less memory and use fewer shared memory
   slots (add [285]-fs 1.0 for one less slot).


   Q-47: How can I make x11vnc use MORE system resources?

   You can try [286]-threads and dial down the wait time (e.g. -wait 1)
   and possibly dial down [287]-defer as well. Note that if you try to
   increase the "frame rate" too much you can bog down the server end
   with the extra work it needs to do compressing the framebuffer data,
   etc.

   That said, it is possible to "stream" video via x11vnc if the video
   window is small enough. E.g. a 256x192 xawtv TV capture window (using
   the x11vnc [288]-id option) can be streamed over a LAN or wireless at
   a reasonable frame rate.


   Q-48: I use x11vnc over a slow link with high latency (e.g. dialup
   modem), is there anything I can do to speed things up?

   Some things you might want to experiment with (most of which will help
   performance on faster links as well):

     X server/session parameters:
     * Configure the X server bits per pixel to 16bpp or even 8bpp.
       (reduces amount of data needed to be sent)
     * Use a smaller desktop size (e.g. 1024x768 instead of 1280x1024)
     * Make sure the desktop background is a solid color (the background
       is resent every time it is re-exposed). Consider using the
       [289]-solid [color] option.
     * Configure your window manager or desktop "theme" to not use fancy
       images, shading, and gradients for the window decorations, etc.
       Disable Opaque moves, resizes, and animations.
     * Avoid small scrolls of large windows using the Arrow keys or
       scrollbar. Try to use PageUp/PageDown instead.
     * Turn off Anti-aliased fonts on your system, web browser,
       terminals, etc. AA fonts do not compress as well as traditional
       fonts.
     * On XFree86 turn on the Shadow Framebuffer to speed up reading.
       (Option "ShadowFB" "true", and possibly Option "NoAccel" "true" as
       well, in the Device section of /etc/X11/XF86Config) This disables
       2D acceleration on the physical display and so is probably not
       worth it, but could be of use in some situations.

     VNC viewer parameters:
     * Use a [290]TightVNC enabled viewer!
     * Make sure the tight encoding is being used (look at vncviewer and
       x11vnc outputs)
     * Request 8 bits per pixel using -bgr233 (up to 4X speedup over
       depth 24 TrueColor (32bpp), but colors will be off)
     * The -depth option is similar to -bgr233 in reducing the requested
       number of bits per pixel.
     * Try increasing the TightVNC -compresslevel (compresses more on
       server side before sending, but uses more CPU)
     * Try reducing the TightVNC -quality (increases JPEG compression,
       but is lossy)
     * Try other VNC encodings via -encodings (tight is probably fastest,
       but you should check)
     * On the machine where vncviewer is run, make sure Backing Store is
       enabled (XFree86 disables it by default causing re-exposures of
       vncviewer to be very slow)

     x11vnc parameters:
     * Try using [291]-nodragging (no screen updates when dragging mouse,
       but sometimes you miss visual feedback)
     * Try the [292]-progressive pixelheight mode with the block
       pixelheight 100 or so (delays sending vertical blocks since they
       may change while viewer is receiving earlier ones)
     * Set [293]-fs 1.0 (disables fullscreen updates)
     * Try increasing [294]-wait or [295]-defer (reduces the maximum
       "frame rate", but won't help much for large screen changes)
     * If you just want to watch one (simple) window use [296]-id (cuts
       down extraneous polling and updates, but can be buggy or
       insufficient)
     * Set [297]-nosel (disables all clipboard selection exchange)
     * Use [298]-nocursor and [299]-nocursorpos (repainting the remote
       cursor position and shape takes resources and round trips)


   Q-49: Does x11vnc support the X DAMAGE Xserver extension to find
   modified regions of the screen quickly and efficiently?

   Yes, as of Mar/2005 in the libvncserver CVS x11vnc will use the X
   DAMAGE extension by default if it is available on the display. This
   requires libXdamage to be available in the build environment as well
   (recent Linux distros and Solaris 10 have it).

   The DAMAGE extension enables the X server to report changed regions of
   the screen back to x11vnc. So x11vnc doesn't have to guess where the
   changes are (by polling the entire screen every 2-4 seconds). The use
   of X DAMAGE dramatically reduces the load when the screen is not
   changing very much (i.e. most of the time). It also noticeably
   improves updates, especially for very small changed areas (e.g. clock
   ticking, cursor flashing, typing, etc).

   Note that the DAMAGE extension does not speed up the actual reading of
   pixels from the video card framebuffer memory, by, say, mirroring them
   in main memory. So reading the fb is still painfully [300]slow (e.g.
   5MB/sec), and so even using X DAMAGE when large changes occur on the
   screen the bulk of the time is still spent retrieving them.

   Unfortunately the current Xorg DAMAGE extension implementation can at
   times be overly cautious and report very large rectangles as "damaged"
   even though only a small portion of the pixels have actually been
   modified. This behavior is often the fault of the window manager (e.g.
   it redraws the entire, unseen, frame window underneath the application
   window when it gains focus), or the application itself (e.g. does
   large, unnecessary repaints).

   To work around this deficiency, x11vnc currently only trusts small
   DAMAGE rectangles to contain real damage. The larger rectangles are
   only used as hints to focus the traditional scanline polling (i.e. if
   a scanline doesn't intersect a recent DAMAGE rectangle, the scan is
   skipped). You can use the "[301]-xd_area A" option to adjust the size
   of the trusted DAMAGE rectangles. The default is 20000 pixels (e.g. a
   140x140 square, etc). Use "-xd_area 0" to disable the cutoff and trust
   all DAMAGE rectangles.

   The option "[302]-xd_mem f" may also be of use in tuning the
   algorithm. To disable using DAMAGE entirely use "[303]-noxdamage".


   Q-50: When I drag windows around with the mouse or scroll up and down
   things really bog down (unless I do the drag in a single, quick
   motion). Is there anything to do to improve things?

   This problem is primarily due to [304]slow hardware read rates from
   video cards: as you scroll or move a large window around the screen
   changes are much too rapid for x11vnc to keep up them (it can usually
   only read the video card at about 5-10 MB/sec, so it can take a good
   fraction of a second to read the changes induce from moving a large
   window, if this to be done a number of times in succession the window
   or scroll appears to "lurch" forward). See the description in the
   [305]-pointer_mode option for more info. The next bottleneck is
   compressing all of these changes and sending them out to connected
   viewers, however the VNC protocol is pretty much self-adapting with
   respect to that (updates are only packaged and sent when viewers ask
   for them).

   As of Jan/2004 there are some improvements in the libvncserver CVS
   tree. The default should now be much better than before and dragging
   small windows around should no longer be a huge pain. If for some
   reason these changes make matters worse, you can go back to the old
   way via the "[306]-pointer_mode 1" option.

   Also added was the [307]-nodragging option that disables all screen
   updates while dragging with the mouse (i.e. mouse motion with a button
   held down). This gives the snappiest response, but might be undesired
   in some circumstances when you want to see the visual feedback while
   dragging (e.g. menu traversal or text selection).

   As of Dec/2004 in the libvncserver CVS the [308]-pointer_mode n option
   was introduced. n=1 is the original mode, n=2 an improvement, etc..
   See the -pointer_mode n help for more info.

   Also, in some circumstances the [309]-threads option can improve
   response considerably. Be forewarned that if more than one vncviewer
   is connected at the same time then libvncserver may not be thread safe
   (try to get the viewers to use different VNC encodings, e.g. tight and
   ZRLE).

   See the [310]wireframe FAQ and [311]scrollcopyrect FAQ below for
   schemes to sweep this problem under the rug for window moves or
   resizes and for some window scrolls.


   Q-51: Why not do something like wireframe animations to avoid the
   windows "lurching" when being moved or resized?

   Nice idea for a hack! As of Apr/2005 in the libvncserver CVS x11vnc by
   default will apply heuristics to try to guess if a window is being
   (opaquely) moved or resized. If such a change is detected framebuffer
   polling and updates will be suspended and only an animated "wireframe"
   (a rectangle outline drawn where the moved/resized window would be) is
   shown. When the window move/resize stops, it returns to normal
   processing: you should only see the window appear in the new position.
   This spares you from interacting with a "lurching" window between all
   of the intermediate steps. BTW the lurching is due to [312]slow video
   card read rates (see [313]here too). A displacement, even a small one,
   of a large window requires a non-negligible amount of time, a good
   fraction of a second, to read in from the hardware framebuffer.

   The mode is currently on by default because most people are inflicted
   with the problem. It can be disabled with the [314]-nowireframe option
   (aka -nowf). Why might one want to turn off the wireframing? Since
   x11vnc is merely guessing when windows are being moved/resized, it may
   guess poorly for your window-manager or desktop, or even for the way
   you move the pointer. If your window-manager or desktop already does
   its own wireframing then this mode is a waste of time and could do the
   wrong thing occasionally. There may be other reasons the new mode
   feels unnatural. If you have very expensive video hardware (SGI) or
   are using an in-RAM video framebuffer (SunRay, ShadowFB, Xvfb), the
   read rate from that framebuffer may be very fast (100's of MB/sec) and
   so you don't really see much lurching: opaque moves look smooth in
   x11vnc. Note: ShadowFB is often turned on when you are using the
   vesafb or fbdev XFree86 video driver instead of a native one so you
   might be using it already and not know.

   The heuristics used to guess window motion or resizing are simple, but
   are not fool proof: x11vnc is sometimes tricked and so you'll
   occasionally see the lurching opaque move and rarely something even
   worse. First it assumes that the move/resize will occur with a mouse
   button pressed, held down and dragged (of course this is only mostly
   true). Next it will only consider a window for wireframing if the
   mouse pointer is initially "close enough" to the edges of the window
   frame, e.g. you have grabbed the title bar or a resizer edge (this
   requirement can be disabled). If these are true, it will wait an
   amount of time to see if the window starts moving or resizing. If it
   does, it starts drawing the wireframe "outline" of where the window
   would be. When the mouse button is released, or a timeout occurs, it
   goes back to the standard mode to allow the actual framebuffer changes
   to propagate to the viewers.

   These parameters can be tweaked:
     * Color/Shade of the wireframe.
     * Linewidth of the outline frame.
     * Cutoff size of windows to not apply wireframing to.
     * Cutoffs for closeness to Top, Bottom, Left, and Right edges of
       window.
     * Maximum time to wait for dragging pointer events.
     * Maximum time to wait for the window to start moving/resizing.
     * Maximum time to show a wireframe animation.
     * Minimum time between sending wireframe outlines.

   See the [315]"-wireframe tweaks" option for more details. On a slow
   link, e.g. dialup modem, you may want to increase all four of these
   times, e.g. double them from the defaults.


   CopyRect encoding:  In addition to the above there is the
   [316]"-wirecopyrect mode" option. It is also on by default. This
   instructs x11vnc to not only show show the wireframe animation, but to
   also instruct all connected VNC viewers to locally translate the
   window image data from the original position to the new position on
   the screen when the animation is done. This speedup is the VNC
   CopyRect encoding: the framebuffer update doesn't need to send the
   actual new image data. This is nice in general, and very convenient
   over a slow link, but since it is based on heuristics you may need to
   disable it with the -nowirecopyrect option (aka -nowcr) if it works
   incorrectly or unnaturally for you.

   The -wirecopyrect modes are: "never" (same as -nowirecopyrect); "top",
   only apply the CopyRect if the window is appears to be on the top of
   the window stack and is not obstructed by other windows; and "always"
   to always try to apply the CopyRect (obstructed regions are usually
   clipped off and not translated).

   Note that some desktops (KDE and xfce) appear to mess with the window
   stacking in ways that are not yet clear. In these cases x11vnc works
   around the problem by applying the CopyRect even if obscuring windows'
   data is translated! Use -nowirecopyrect if this yields undesirable
   effects for your desktop.

   Also, the CopyRect encoding may give incorrect results under -scale
   (depending on the scale factor the CopyRect operation is often only
   approximate: the correctly scaled framebuffer will be slightly
   different from the translated one). x11vnc will try to push a
   "cleanup" update after the CopyRect if -scale is in effect. Use
   -nowirecopyrect if this or other painting errors are unacceptable.


   Q-52: Can x11vnc try to apply heuristics to detect when an window is
   scrolling its contents and use the CopyRect encoding for a speedup?

   Another nice idea for a hack! As of May/2005 in the libvncserver CVS
   x11vnc will by default apply heuristics to try to detect if the the
   window that has the input focus is scrolling its contents (but only
   when x11vnc is feeding user input (keystroke or pointer) to the X
   server). So, when detected, scrolls induced by dragging on a scrollbar
   or by typing (e.g. Up or Down arrows, hitting Return in a terminal
   window, etc), will show up much more quickly than via the standard
   x11vnc screen polling update mechanism. There will be a speedup for
   both slow and fast links to viewers. For slow links the speedup is
   mostly due to the CopyRect encoding not requiring the image data to be
   transmitted over the network. For fast links the speedup is primarily
   due to x11vnc not having to read the scrolled framebuffer data from
   the X server (recall that reading from the hardware framebuffer is
   [317]slow).

   To do this x11vnc uses the RECORD X extension to snoop the X11
   protocol between the X client with the focus window and the X server.
   This extension is usually present on most X servers. On XFree86/Xorg
   it can be enabled via Load "record" in the Module section of the
   config file.

   Currently the RECORD extension is used as little as possible so as to
   not slow down regular use. Only simple heuristics are applied to
   detect XCopyArea and XConfigureWindow calls from the application.
   These catch a lot of scrolls, e.g. in mozilla/firefox and in terminal
   windows like gnome-terminal and xterm. Unfortunately the toolkits KDE
   applications use make scroll detection less effective (only rarely are
   they detected: i.e. Konqueror and Konsole don't work). An interesting
   project, that may be the direction x11vnc takes, is to record all of
   the X11 protocol from all clients and try to "tee" the stream into a
   modified Xvfb watching for CopyRect and other VNC speedups. A
   potential issue is the RECORD stream is delayed from actual view on
   the X server display: if one falls too far behind it could become a
   mess...

   The initial implementation of [318]-scrollcopyrect option is useful in
   that it detects many scrolls and thus gives a much nicer working
   environment (especially when combined with the [319]-wireframe
   [320]-wirecopyrect [321]options, which are also on by default). The
   fact that there aren't long delays or lurches during scrolling is the
   primary improvement. But there are some drawbacks:
     * Not all scrolls are detected. Some apps scroll windows in ways
       that cannot currently be detected, and other times x11vnc "misses"
       the scroll due to timeouts, etc. Sometimes it is more distracting
       that a speedup occasionally doesn't work as opposed to being
       consistently slow!
     * For rapid scrolling (i.e. sequence of many scrolls over a short
       period) there can be painting errors (tearing, bunching up, etc.)
       during the scroll. These will repair themselves after the scroll
       is over, but when they are severe it can be distracting. Try to
       think of the approximate window contents as a quicker and more
       useful "animation" compared to the slower polling scheme...
     * Scrolling inside shells in terminal windows (gnome-terminal,
       xterm), can lead to odd painting errors. This is because x11vnc
       did not have time to detect a screen change just before the scroll
       (most common is the terminal undraws the block cursor before
       scrolling the text up: in the viewer you temporarily see multiple
       block cursors). Another issue is with things like more(1): scroll
       detection for 5-6 lines happens nicely, but then it can't keep up
       and so there is a long pause for the standard polling method to
       deliver the remaining updates.
     * More rarely sometimes painting errors are not repaired after the
       scroll is over. This may be a bug in x11vnc or libvncserver, or it
       may be an inescapable fact of the CopyRect encoding and the delay
       between RECORD callbacks and what is actually on the X display.
       One can tap the Alt_L key (Left "Alt" key) 3 times in a row to
       signal x11vnc to refresh the screen to all viewers. Your
       VNC-viewer may have its own screen refresh hot-key or button. See
       also: [322]-fixscreen
     * Some applications, notably OpenOffice, do XCopyArea scrolls in
       weird ways that assume ancestor window clipping is taking place.
       See the [323]-scr_skip option for ways to tweak this on a
       per-application basis.
     * Selecting text while dragging the mouse may be slower, especially
       if the Button-down event happens near the window's edge. This is
       because the scrollcopyrect scheme is watching for scrolls via
       RECORD and has to wait for a timeout to occur before it does the
       update.
     * For reasons not yet understood the RECORD extension can stop
       responding (and hence scrolls are missed). As a workaround x11vnc
       attempts to reset the RECORD connection every 60 seconds or so.
       Another workaround is to type 5 Super_L (Left Super/Windows-Flag
       key) in a row to reset RECORD. Work is in progress to try to fix
       this bug.
     * Sometimes you need to "retrain" x11vnc for a certain window
       because it fails to detect scrolls in it. Sometimes clicking
       inside the application window or selecting some text in it to
       force the focus helps.
     * When using the [324]-scale option there will be a quick CopyRect
       scroll, but it needs to be followed by a slower "cleanup" update.
       This is because for a fixed finite screen resolution (e.g. 75 dpi)
       scaling and copyrect-ing are not exactly independent. Scaling
       involves a blending of nearby pixels and if you translate a pixel
       the neighbor pixel weighting may be different. So you have to wait
       a bit for the cleanup update to finish. On slow links x11vnc will
       automatically decide to not detect scrolls when -scale is in
       effect. In general it will also try to defer the cleanup update if
       possible.

   If you find the -scrollcopyrect behavior too approximate or
   distracting you can go back to the standard polling-only update method
   with the [325]-noscrollcopyrect or -noscr for short. If you find some
   extremely bad and repeatable behavior for -scrollcopyrect please
   report a bug.

   Alternatively, as with -wireframe, there are many tuning parameters to
   try to improve the situation. You can also access these parameters
   inside the gui under "Tuning". These parameters can be tweaked:
     * The minimum pixel area of a rectangle to be watched for scrolls.
     * A list if application names to skip scroll detection.
     * Which keystrokes should trigger scroll detection.
     * Which applications should have a "terminal" tweak applied to them.
     * When repeating keys (e.g. Up arrow) should be discarded to
       preserve a scroll.
     * Cutoffs for closeness to Top, Bottom, Left, and Right edges of
       window for mouse induced scrolls.
     * Set timeout parameters for keystroke induced scrolls.
     * Set timeout parameters for mouse pointer induced scrolls.
     * Have the full screen be periodically refreshed to fix painting
       errors.



   [Mouse Cursor Shapes]

   Q-53: Why isn't the mouse cursor shape (the little icon shape where
   the mouse pointer is) correct as I move from window to window?

   On X servers supporting XFIXES or Solaris/IRIX Overlay extensions it
   is possible for x11vnc to do this correctly. See the paragraphs below.

   Historically, the X11 mouse cursor shape (i.e. little picture: an
   arrow, X, I-beam, resizer, etc) is one of the few write-only objects
   in X11. That is, an application can tell the X server what the cursor
   shape should be when the pointer is in a given window, but a program
   (like x11vnc) unfortunately cannot read this information. I believe
   this is because the cursor shape is often downloaded to the graphics
   hardware (video card), but I could be mistaken.

   A simple kludge is provided by the "[326]-cursor X" option that
   changes the cursor when the mouse is on the root background (or any
   window has the same cursor as the root background). Note that desktops
   like GNOME or KDE often cover up the root background, so this won't
   work for those cases. Also see the "[327]-cursor some" option for
   additional kludges.

   Note that as of Aug/2004 in the libvncserver CVS, on Solaris using the
   SUN_OVL overlay extension and IRIX, x11vnc can show the correct mouse
   cursor when the [328]-overlay option is supplied. See [329]this FAQ
   for more info.

   Also as of Dec/2004 in the libvncserver CVS XFIXES X extension support
   has been added to allow exact extraction of the mouse cursor shape.
   XFIXES fixes the problem of the cursor-shape being write-only: x11vnc
   can now query the X server for the current shape and send it back to
   the connected viewers. XFIXES is available on recent Linux Xorg based
   distros and [330]Solaris 10.

   The only XFIXES issue is the handling of alpha channel transparency in
   cursors. If a cursor has any translucency then in general it must be
   approximated to opaque RGB values. There are some situations where the
   cursor transparency can also handled exactly: when the VNC Viewer
   requires the cursor shape be drawn into the VNC framebuffer or if you
   apply a patch to your VNC Viewer to extract hidden alpha channel data
   under 32bpp. [331]Details can be found here.


   Q-54: When using XFIXES cursorshape mode, some of the cursors look
   really bad with extra black borders around the cursor and other cruft.
   How can I improve their appearance?

   This happens for cursors with transparency ("alpha channel"); regular
   X cursors (bitmaps) should be correct. Unfortunately x11vnc 0.7 was
   released with a very poor algorithm for approximating the
   transparency, which led to the ugly black borders.

   The problem is as follows: XFIXES allows x11vnc to retrieve the
   current X server cursor shape, including the alpha channel for
   transparency. For traditional bitmap cursors the alpha value will be 0
   for completely transparent pixels and 255 for completely opaque
   pixels; whereas for modern, eye-candy cursors an alpha value between 0
   and 255 means to blend in the background colors to that degree with
   the cursor colors. The pixel color blending formula is something like
   this: Red = Red_cursor * a + Red_background * (1 - a), (where here 0
   =< a =< 1), with similar for Green and Blue. The VNC protocol does not
   currently support an alpha channel in cursors: it only supports
   regular X bitmap cursors and Rich Cursors that have RGB (Red, Green,
   Blue) color data, but no "A" = alpha data. So in general x11vnc has to
   approximate a cursor with transparency to create a Rich Cursor. This
   is easier said than done: some cursor themes have cursors with
   complicated drop shadows and other forms of translucency.

   Anyway, for the x11vnc 0.7.1 release the algorithm for approximating
   transparency is much improved and hopefully gives decent cursor shapes
   for most cursor themes and you don't have to worry about it.

   In case it still looks bad for your cursor theme, there are (of
   course!) some tunable parameters. The "[332]-alphacut n" option lets
   you set the threshold "n" (between 0 and 255): cursor pixels with
   alpha values below n will be considered completely transparent while
   values equal to or above n will be completely opaque. The default is
   240. The "[333]-alphafrac f" option tries to correct individual
   cursors that did not fare well with the default -alphacut value: if a
   cursor has less than fraction f (between 0.0 and 1.0) of its pixels
   selected by the default -alphacut, the threshold is lowered until f of
   its pixels are selected. The default fraction is 0.33.

   Finally, there is an option [334]-alpharemove that is useful for
   themes where many cursors are light colored (e.g. "whiteglass").
   XFIXES returns the cursor data with the RGB values pre-multiplied by
   the alpha value. If the white cursors look too grey, specify
   -alpharemove to brighten them by having x11vnc divide out the alpha
   value.


   Q-55: In XFIXES mode, are there any hacks to handle cursor
   transparency ("alpha channel") exactly?

   As of Jan/2005 in the CVS, libvncserver has been modified to allow an
   alpha channel (i.e. RGBA data) for Rich Cursors. So x11vnc can now
   send the alpha channel data to libvncserver. However, this data will
   only be used for VNC clients that do not support the
   CursorShapeUpdates VNC extension (or have disabled it). It can be
   disabled for all clients with the [335]-nocursorshape x11vnc option.
   In this case the cursor is drawn, correctly blended with the
   background, into the VNC framebuffer before being sent out to the
   client. So the alpha blending is done on the x11vnc side. Use the
   [336]-noalphablend option to disable this behavior (always approximate
   transparent cursors with opaque RGB values).

   The CursorShapeUpdates VNC extension complicates matters because the
   cursor shape is sent to the VNC viewers supporting it, and the viewers
   draw the cursor locally. This improves response over slow links. Alpha
   channel data for these locally drawn cursors is not supported by the
   VNC protocol.

   However, in the libvncserver CVS there is a patch to the TightVNC
   viewer to make this work for CursorShapeUpdates under some
   circumstances. This hack is outside of the VNC protocol. It requires
   the screens on both sides to be depth 24 at 32bpp (it uses the extra 8
   bits to secretly hide the cursor alpha channel data). Not only does it
   require depth 24 at 32bpp, but it also currently requires the client
   and server to be of the same endianness (otherwise the hidden alpha
   data gets reset to zero by a libvncserver translation function; we can
   fix this at some point if there is interest). The patch is for the
   TightVNC 1.3dev5 Unix vncviewer and it enables the TightVNC viewer to
   do the cursor alpha blending locally. The patch code should give an
   example on how to change the Windows TightVNC viewer to achieve the
   same thing (send me the patch if you get that working).

   [Mouse Pointer]

   Q-56: Why does the mouse arrow just stay in one corner in my
   vncviewer, whereas my cursor (that does move) is just a dot?

   This default takes advantage of a [337]tightvnc extension
   (CursorShapeUpdates) that allows specifying a cursor image shape for
   the local VNC viewer. You may disable it with the [338]-nocursor
   option to x11vnc if your viewer does not have this extension.

   Note: as of Aug/2004 in the libvncserver CVS this should be fixed: the
   default for non-tightvnc viewers (or ones that do not support
   CursorShapeUpdates) will be to draw the moving cursor into the x11vnc
   framebuffer. This can also be disabled via -nocursor.


   Q-57: Can I take advantage of the TightVNC extension to the VNC
   protocol where Cursor Positions Updates are sent back to all connected
   clients (i.e. passive viewers can see the mouse cursor being moved
   around by another viewer)?

   Use the [339]-cursorpos option when starting x11vnc. A VNC viewer must
   support the Cursor Positions Updates for the user to see the mouse
   motions (the TightVNC viewers support this). As of Aug/2004 in the
   libvncserver CVS -cursorpos is the default. See also [340]-nocursorpos
   and [341]-nocursorshape.
   
   
   Q-58: Is it possible to swap the mouse buttons (e.g. left-handed
   operation), or arbitrarily remap them? How about mapping button clicks
   to keystrokes, e.g. to partially emulate Mouse wheel scrolling?

   You can remap the mouse buttons via something like: [342]-buttonmap
   13-31 (or perhaps 12-21). Also, note that xmodmap(1) lets you directly
   adjust the X server's button mappings, but in some circumstances it
   might be more desirable to have x11vnc do it.

   One user had an X server with only one mouse button(!) and was able to
   map all of the VNC client mouse buttons to it via: -buttonmap 123-111.

   Note that the [343]-debug_pointer option prints out much info for
   every mouse/pointer event and is handy in solving problems.

   To map mouse button clicks to keystrokes you can use the alternate
   format where the keystrokes are enclosed between colons like this
   :<KeySym>: in place of the mouse button digit. For a sequence of
   keysyms separate them with "+" signs. Look in the include file
   <X11/keysymdef.h>, or use xev(1), or -debug_keyboard to fine the
   keysym names. Button clicks can also be included in the sequence via
   the fake keysyms Button1, etc.

   As an example, suppose the VNC viewer machine has a mouse wheel (these
   generate button 4 and 5 events), but the machine that x11vnc is run on
   only has the 3 regular buttons. In normal operation x11vnc will
   discard the button 4 and 5 events. However, either of the following
   button maps could possibly be of use emulating the mouse wheel events
   in this case:
  -buttonmap 12345-123:Prior::Next:
  -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:

   Exactly what keystroke "scrolling" events they should be bound to
   depends on one's taste. If this method is too approximate, one could
   consider not using [344]-buttonmap but rather configuring the X server
   to think it has a mouse with 5 buttons even though the physical mouse
   does not.

   Note that when a keysym-mapped mouse button is clicked down this
   immediately generates the key-press and key-release events (for each
   keysym in turn if the mapping has a sequence of keysyms). When the
   mouse button goes back up nothing is generated.

   If you include modifier keys like Shift_L instead of key-press
   immediately followed by key-release the state of the modifier key is
   toggled (however the initial state of the modifier key is ignored). So
   to map the right button to type my name 'Karl Runge' I could use this:
  -buttonmap 3-:Shift_L+k+Shift_L+a+r+l+space+Shift_L+r+Shift_L+u+n+g+e:

   (yes, this is getting a little silly).

   BTW, Coming the other way around, if the machine you are sitting at
   does not have a mouse wheel, but the remote machine does (or at least
   has 5 buttons configured), this key remapping can be useful:
  -remap Super_R-Button4,Menu-Button5

   you just tap those two keys to get the mouse wheel scrolls (this is
   more useful than the Up and Down arrow keys because a mouse wheel
   "click" usually gives a multi-line scroll).
   [Keyboard Issues]

   Q-59: How can I get my AltGr and Shift modifiers to work between
   keyboards for different languages?

   The option [345]-modtweak should be of some use for this. It is a mode
   that monitors the state of the Shift and AltGr Modifiers and tries to
   deduce the correct keycode to send, possibly by sending fake modifier
   key presses and releases in addition to the actual keystroke.

   Update:  As of Jul/2004 in the libvncserver CVS, -modtweak is now the
   default (use -nomodtweak to get the old behavior). This was done
   because it was noticed on newer XFree86 setups even on bland "us"
   keyboards like "pc104 us" XFree86 included a "ghost" key with both "<"
   and ">" it. This key does not exist on the keyboard (see [346]this FAQ
   for more info). Without -modtweak there was then an ambiguity in the
   reverse map keysym => keycode, making it so the "<" symbol could not
   be typed.

   Also see the [347]FAQ about the -xkb option for a more powerful method
   of modifier tweaking for use on X servers with the XKEYBOARD
   extension.

   When trying to resolve keyboard mapping problems, note that the
   [348]-debug_keyboard option prints out much info for every keystroke
   and so can be useful debugging things.


   Q-60: When I try to type a "<" (i.e. less than) instead I get ">"
   (i.e. greater than)! Strangely, typing ">" works OK!!

   Does your keyboard have a single key with both "<" and ">" on it? Even
   if it doesn't, your X server may think your keyboard has such a key
   (e.g. pc105 in the XF86Config file when it should be something else,
   say pc104).

   The problem here is that on the Xserver where x11vnc is run there are
   two keycodes that correspond to the "<" keysym. Run something like
   this to see:

  xmodmap -pk | egrep -i 'KeyCode|less|greater'
  There are 4 KeySyms per KeyCode; KeyCodes range from 8 to 255.
      KeyCode     Keysym (Keysym) ...
       59         0x002c (comma)  0x003c (less)
       60         0x002e (period) 0x003e (greater)
       94         0x003c (less)   0x003e (greater)

   That keycode 94 is the special key with both "<" and ">". When x11vnc
   receives the "<" keysym over the wire from the remote VNC client, it
   unfortunately maps it to keycode 94 instead of 59, and sends 94 to the
   X server. Since Shift is down (i.e. you are Shifting the comma key),
   the X server interprets this as Shifted-94, which is ">".

   A workaround in the X server configuration is to "deaden" that special
   key:

  xmodmap -e "keycode 94 = "

   However, one user said he had to do this:

  xmodmap -e "keycode 94 = 0x002c 0x003c"

   (If the numerical values are different for your setup, substitute the
   ones that correspond to your display. The above xmodmap scheme can
   often be used to work around other ambiguous keysym to keycode
   mappings).

   Alternatively, here are some x11vnc options to try to work around the
   problem:
   -modtweak

   and
   -remap less-comma

   These are convenient in that they do not modify the actual X server
   settings. The former ([349]-modtweak) is a mode that monitors the
   state of the Shift and AltGr modifiers and tries to deduce the correct
   keycode sequence to send. Since Jul/2004 -modtweak is now the default.
   The latter ([350]-remap less-comma) is an immediate remapping of the
   keysym less to the keysym comma when it comes in from a client (so
   when Shift is down the comma press will yield "<").

   See also the [351]FAQ about the -xkb option as a possible workaround
   using the XKEYBOARD extension.

   Note that the [352]-debug_keyboard option prints out much info for
   every keystroke to aid debugging keyboard problems.


   Q-61: I'm using an "international" keyboard (e.g. German "de", or
   Danish "dk") and the -modtweak mode works well if the VNC viewer is
   run on a Unix/Linux machine with a similar keyboard.   But if I run
   the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or
   Windows with any keyboard, I can't type some keys like:   "@", "$",
   "<", ">", etc. How can I fix this?

   The problem with Windows is it does not seem to handle AltGr well. It
   seems to fake it up by sending Control_L+Alt_R to applications. The
   Windows VNC viewer sends those two down keystrokes out on the wire to
   the VNC server, but when the user types the next key to get, e.g., "@"
   the Windows VNC viewer sends events bringing the up the
   Control_L+Alt_R keys, and then sends the "@" keysym by itself.

   The Unix/Linux VNC viewer on a "us" keyboard does a similar thing
   since "@" is the Shift of the "2" key. The keysyms Shift and "@" are
   sent to the VNC server.

   In both cases no AltGr is sent to the VNC server, but we know AltGr is
   needed on the physical international keyboard to type a "@".

   This all worked fine with x11vnc running with the [353]-modtweak
   option (it figures out how to adjust the Modifier keys (Shift or
   AltGr) to get the "@"). However it fails under recent versions of
   XFree86 (and the X.org fork). These run the XKEYBOARD extension by
   default and make heavy use of it to handle international keyboards.

   To make a long story short, on these newer XFree86 setups the
   traditional X keymap lookup x11vnc uses is no longer accurate. x11vnc
   can't find the keysym "@" anywhere in the keymapping! (even though it
   is in the XKEYBOARD extended keymapping).

   How to Solve: As of Jul/2004 in the libvncserver CVS x11vnc has two
   changes:
     * -modtweak (tweak Modifier keys) is now the default (use
       -nomodtweak to go back to the old way)
     * there is a new option -xkb to use the XKEYBOARD extension API to
       do the Modifier key tweaking.

   The [354]-xkb option seems to fix all of the missing keys: "@", "<",
   ">", etc.: it is recommended that you try it if you have this sort of
   problem. Let us know if there are any remaining problems (see the next
   paragraph for some known problems). If you specify the -debug_keyboard
   (aka -dk) option twice you will get a huge amount of keystroke
   debugging output (send it along with any problems you report).

   Known problems:
     * One user had to disable a "ghost" Mode_switch key that was causing
       problems under -xkb. His physical AltGr key was bound to
       ISO_Level3_Shift (which seems to be the XKEYBOARD way of doing
       things), while there was a ghost key Mode_switch (which seems to
       be obsolete) in the mapping as well. Both of these keysyms were
       bound to Mod5 and x11vnc was unfortunately choosing Mode_switch.
       From the x11vnc -xkb -dk -dk output it was noted that Mode_switch
       was attached to keycode 93 (no physical key generates this
       keycode) while ISO_Level3_Shift was attached to keycode 113. The
       keycode skipping option was used to disable the ghost key:
       [355]-skip_keycodes 93
     * In implementing -xkb we noticed that some characters were still
       not getting through, e.g. "~" and "^". This is not really an
       XKEYBOARD problem. What was happening was the VNC viewer was
       sending the keysyms asciitilde and asciicircum to x11vnc, but on
       the X server with the international keyboard those keysyms were
       not mapped to any keys. So x11vnc had to skip them.
       The way these characters are typically entered on international
       keyboards is by "dead" (aka "mute") keys. E.g. to enter "~" at the
       physical display the keysym dead_tilde is pressed and released
       (this usually involves holding AltGr down while another key is
       pressed) and then space is pressed. (this can also be used get
       characters with the "~" symbol on top, e.g. "" by typing "a"
       instead of space).
       What to do? In general the VNC protocol has not really solved this
       problem: what should be done if the VNC viewer sends a keysym not
       recognized by the VNC server side? Workarounds can possibly be
       created using the [356]-remap x11vnc option:
  -remap asciitilde-dead_tilde,asciicircum-dead_circumflex
       etc. Use -remap filename if the list is long. Please send us your
       workarounds for this problem on your keyboard. Perhaps we can have
       x11vnc adjust automatically at some point. Also see the
       [357]-add_keysyms option in the next paragraph.
     * To complement the above workaround using the [358]-remap, an
       option [359]-add_keysyms was added. This option instructs x11vnc
       to bind any unknown Keysyms coming in from VNC viewers to unused
       Keycodes in the X server. This modifies the global state of the X
       server. When x11vnc exits it removes the extra keymappings it
       created. Note that the -remap mappings are applied first, right
       when the Keysym is received from a VNC viewer, and only after that
       would -add_keysyms, or anything else, come into play.


   Q-62: When typing I sometimes get double, triple, or more of my
   keystrokes repeated. I'm sure I only typed them once, what can I do?

   This may be due to an interplay between your X server's key autorepeat
   delay and the extra time delays caused by x11vnc processing.

   Short answer: disable key autorepeating by running the command "xset r
   off" on the Xserver where x11vnc is run (restore via "xset r on") or
   use the new (Jul/2004) [360]-norepeat x11vnc option. You will still
   have autorepeating because that is taken care of on your VNC viewer
   side. Update: as of Dec/2004 -norepeat is now the default. Use -repeat
   to disable it.

   Details: suppose you press a key DOWN and it generates changes in
   large regions of the screen. The CPU and I/O work x11vnc does for the
   large screen change could be longer than your X server's key
   autorepeat delay. x11vnc may not get to processing the key UP event
   until after the screen work is completed. The X server believes the
   key has been held down all this time, and applies its autorepeat
   rules.

   Even without inducing changes in large regions of the screen, this
   problem could arise when accessing x11vnc via a dialup modem or
   otherwise high latency link (e.g. > 250 ms latency).

   Look at the output of "xset q" for the "auto repeat delay" setting. Is
   it low (e.g. < 300 ms)? If you turn off autorepeat completely: "xset r
   off", does the problem go away?

   The workaround is to manually apply "xset r off" and "xset r on" as
   needed, or to use the [361]-norepeat (which has since Dec/2004 been
   made the default). Note that with X server autorepeat turned off the
   VNC viewer side of the connection will (nearly always) do its own
   autorepeating so there is no big loss here, unless someone is also
   working at the physical display and misses his autorepeating.


   Q-63: The x11vnc -norepeat mode is in effect, but I still get repeated
   keystrokes!!

   Are you using x11vnc to log in to an X session? (as described in
   [362]this FAQ) If so, x11vnc is starting before your session and it
   disables autorepeat when you connect, but then after you log in your
   session startup (GNOME, KDE, ...) could be resetting the autorepeat to
   be on. Or it could be something inside your desktop trying to be
   helpful that decides to turn it back on.

   x11vnc in -norepeat mode will by default reset autorepeat to off 2
   times (to help get thru the session startup problem), but it will not
   continue to battle with things turning autorepeat back on. It will
   also turn autorepeat off whenever it goes from a state of zero clients
   to one client. You can adjust the number of resets via "-norepeat N",
   or use "-norepeat -1" to have it keep resetting it whenever autorepeat
   gets turned back on when clients are connected.

   In general you can manually turn autorepeating off by typing "xset r
   off", or a using desktop utility/menu, or "x11vnc -R norepeat". If
   something in your desktop is automatically turning it back on you
   should figure out how to disable that somehow.


   Q-64: The machine where I run x11vnc has an AltGr key, but the local
   machine where I run the VNC viewer does not. Is there a way I can map
   a local unused key to send an AltGr? How about a Compose key as well?

   Something like "[363]-remap Super_R-Mode_switch" x11vnc option may
   work. Note that Super_R is the "Right Windoze(tm) Flaggie" key; you
   may want to choose another. The -debug_keyboard option comes in handy
   in finding keysym names (so does xev(1)).

   For Compose how about "-remap Menu-Multi_key" (note that Multi_key is
   the official name for Compose). To do both at the same time: "-remap
   Super_R-Mode_switch,Menu-Multi_key" or use "-remap filename" to
   specify remappings from a file.


   Q-65: I have a Sun machine I run x11vnc on. Its Sun keyboard has just
   one Alt key labelled "Alt" and two Meta keys labelled with little
   diamonds. The machine where I run the VNC viewer only has Alt keys.
   How can I send a Meta keypress? (e.g. emacs needs this)

   Here are a couple ideas. The first one is to simply use xmodmap(1) to
   adjust the Sun X server. Perhaps xmodmap -e "keysym Alt_L = Meta_L
   Alt_L" will do the trick. (there are other ways to do it, one user
   used: xmodmap -e "keycode 26 = Meta_L" for his setup).

   Since xmodmap(1) modifies the X server mappings you may not want to do
   this (because it affects local work on that machine). Something like
   the [364]-remap Alt_L-Meta_L to x11vnc may be sufficient for ones
   needs, and does not modify the X server environment. Note that you
   cannot send Alt_L in this case, maybe -remap Super_L-Meta_L would be a
   better choice if the Super_L key is typically unused.


   Q-66: Can I map a keystroke to a mouse button click on the remote
   machine?

   This can be done directly in some X servers using AccessX and
   Pointer_EnableKeys, but is a bit awkward. It may be more convenient to
   have x11vnc do the remapping. This can be done via the [365]-remap
   option using the fake "keysyms" Button1, Button2, etc. as the "to"
   keys (i.e. the ones after the "-")

   As an example, consider a laptop where the VNC viewer is run that has
   a touchpad with only two buttons. It is difficult to do a middle
   button "paste" because (using XFree86 Emulate3Buttons) you have to
   click both buttons on the touch pad at the same time. This remapping:
  [366]-remap Super_R-Button2

   maps the Super_R "flag" key press to the Button2 click, thereby making
   X pasting a bit easier.

   Note that once the key goes down, the button down and button up events
   are generated immediately on the x11vnc side. When the key is released
   (i.e. goes up) no events are generated.

   [Screen Related Issues and Features]

   Q-67: The remote display is larger (in number of pixels) than the
   local display I am running the vncviewer on. I don't like the
   vncviewer scrollbars, what I can do?

   vncviewer has a option (usually accessible via F8 key or -fullscreen
   option) for vncviewer to run in full screen, where it will
   automatically scroll when the mouse is near the edge of the current
   view. For quick scrolling, also make sure Backing Store is enabled on
   the machine vncviewer is run on. (XFree86 disables it by default for
   some reason, add Option "backingstore" to XF86Config on the vncviewer
   side).

   BTW, contact me if you are having problems with vncviewer in
   fullscreen mode with your window manager (i.e. no keyboard response).
   I have a workaround for vncviewer using XGrabServer().

   There may also be scaling viewers out there (e.g. TightVNC on Windows)
   that automatically shrink or expand the remote framebuffer to fit the
   local display. Especially for hand-held devices. See also [367]this
   FAQ on x11vnc scaling.


   Q-68: Does x11vnc support server-side framebuffer scaling? (E.g. to
   make the desktop smaller).

   As of Jun/2004 in the libvncserver CVS x11vnc provides basic
   server-side scaling. It is a global scaling of the desktop, not a
   per-client setting. To enable it use the "[368]-scale fraction"
   option. "fraction" can either be a floating point number (e.g. -scale
   0.5) or the alternative m/n fraction notation (e.g. -scale 2/3). Note
   that if fraction is greater than one the display is magnified.

   Extra resources (CPU, memory I/O, and memory) are required to do the
   scaling. If the machine is slow where x11vnc is run with scaling
   enabled, the interactive response can be unacceptable. OTOH, if run
   with scaling on a fast machine the performance degradation is usually
   not a big issue or even noticeable.

   Also, if you just want a quick, rough "thumbnail" of the display you
   can append ":nb" to the fraction to turn on "no blending" mode. E.g.:
   "-scale 1/3:nb" Fonts will be difficult to read, but the larger
   features will be recognizable. BTW, "no blending" mode is forced on
   when scaling 8bpp PseudoColor displays (because blending an indexed
   colormap is a bad idea and leads to random colors).

   One can also use the ":nb" with an integer scale factor (say "-scale
   2:nb") to use x11vnc as a screen magnifier for vision impaired
   [369]applications. Since with integer scale factors the framebuffers
   become huge and scaling operations time consuming, be sure to use
   ":nb" for the fastest response.

   In general for a scaled display if you are using a TightVNC viewer you
   may want to turn off jpeg encoding (e.g. vncviewer -nojpeg host:0).
   There appears to be a noise enhancement effect, especially for regions
   containing font/text: the scaling can introduce some pixel artifacts
   that evidently causes the tight encoding algorithm to incorrectly
   detect the regions as image data and thereby introduce additional
   pixel artifacts due to the lossiness of the jpeg compression
   algorithm. Experiment to see if -nojpeg vncviewer option improves the
   readability of text when using -scale to shrink the display size. Also
   note that scaling may actually slow down the transfer of text regions
   because after being scaled they do not compress as well. (this can
   often be a significant slowdown, e.g. 10X).

   Another issue is that it appears VNC viewers require the screen width
   to be a multiple of 4. When scaling x11vnc will round the width to the
   nearest multiple of 4. To disable this use the ":n4" sub option (like
   ":nb" in the previous paragraph; to specify both use a comma:
   ":nb,n4", etc.)

   If one desires per-client scaling for something like 1:1 from a
   workstation and 1:2 from a smaller device (e.g. handheld), currently
   the only option is to run two (or more) x11vnc processes with
   different scalings listening on separate ports ([370]-rfbport option,
   etc.).

   As of Mar/2005 in the libvncserver CVS x11vnc now scales the mouse
   cursor with the same scale factor as the screen. If you don't want
   that, use the [371]"-scale_cursor frac" option to set the cursor
   scaling to a different factor (e.g. use "-scale_cursor 1" to keep the
   cursor at its natural unscaled size).


   Q-69: Does x11vnc work with Xinerama? (i.e. multiple monitors joined
   together to form one big, single screen).

   Yes, it should generally work because it simply polls the big
   effective screen. If the viewing-end monitor is not as big as the
   remote Xinerama display, then the vncviewer scrollbars, etc, will have
   to be used to pan across the large area.

   There are a couple potential issues however. If the screen is not
   rectangular (e.g. 1280x1024 and 1024x768 monitors joined together),
   then there will be "non-existent" areas on the screen. The X server
   will return "garbage" image data for these areas and so they may be
   distracting to the viewer. The [372]-blackout x11vnc option allows you
   to blacken-out rectangles by specifying their WxH+X+Y geometries. If
   your system has the libXinerama library, the [373]-xinerama x11vnc
   option can be used to have it automatically determine the rectangles
   to be blackened out. (Note on 8bpp PseudoColor displays the fill color
   may not be black).

   Some users have reported that the mouse does not behave properly for
   their Xinerama display: i.e. the mouse cannot be moved to all regions
   of the large display. If this happens try using the [374]-xwarppointer
   option. This instructs x11vnc to fake mouse pointer motions using the
   XWarpPointer function instead of the XTestFakeMotionEvent XTEST
   function. (This may be due to a bug in the X server for XTEST when
   Xinerama is enabled).


   Q-70: Can I use x11vnc on a multi-headed display that is not Xinerama
   (i.e. separate screens :0.0, :0.1, ... for each monitor)?

   You can, but it is a little bit awkward: you must start separate
   x11vnc processes for each screen, and on the viewing end start up
   separate VNC viewer processes connecting to them. e.g. on the remote
   end:
  x11vnc -display :0.0 -bg -q -rfbport 5900
  x11vnc -display :0.1 -bg -q -rfbport 5901

   (this could be automated in the display manager Xsetup for example)
   and then on the local machine where you are sitting:
  vncviewer somehost:0 &
  vncviewer somehost:1 &

   Note: if you are running on Solaris 8 or earlier you can easily hit up
   against the maximum of 6 shm segments per process (for Xsun in this
   case) from running multiple x11vnc processes. You should modify
   /etc/system as mentioned in another [375]FAQ to increase the limit. It
   is probably also a good idea to run with the [376]-onetile option in
   this case (to limit each x11vnc to 3 shm segments), or even
   [377]-noshm to use no shm segments.


   Q-71: Can x11vnc show only a portion of the display? (E.g. for a
   special purpose rfb application).

   As of Mar/2005 in the libvncserver CVS x11vnc has the "[378]-clip
   WxH+X+Y" option to select a rectangle of width W, height H and offset
   (X, Y). Thus the VNC screen will be the clipped sub-region of the
   display and be only WxH in size.

   This also works to view a sub-region of a single application window if
   the [379]-id or [380]-sid options are used. The offset is measured
   from the upper left corner of the selected window.


   Q-72: Does x11vnc support the XRANDR (X Resize, Rotate and Reflection)
   extension? Whenever I rotate or resize the screen x11vnc just seems to
   crash.

   As of Dec/2004 in the libvncserver CVS x11vnc supports XRANDR. You
   enable it with the [381]-xrandr option to make x11vnc monitor XRANDR
   events and also trap X server errors if the screen change occurred in
   the middle of an X call like XGetImage. Once it traps the screen
   change it will create a new framebuffer using the new screen. If the
   connected vnc viewers support the NewFBSize VNC extension (Windows
   TightVNC viewer and RealVNC 4.0 windows and Unix viewers do) then the
   viewer will automatically resize. Otherwise, the new framebuffer is
   fit as best as possible into the original viewer size (portions of the
   screen may be clipped, unused, etc). For these viewers you can try the
   [382]-padgeom option to make the region big enough to hold all resizes
   and rotations.

   If you specify "-xrandr newfbsize" then vnc viewers that do not
   support NewFBSize will be disconnected before the resize. If you
   specify "-xrandr exit" then all will be disconnected and x11vnc will
   terminate.


   Q-73: Why is the view in my VNC viewer completely black? Or why is
   everything flashing around randomly?

   See the next FAQ for a possible explanation.


   Q-74: I use Linux Virtual Consoles (VC's) to implement 'Fast User
   Switching' between users' sessions (e.g. Betty is on Ctrl-Alt-F7,
   Bobby is on Ctrl-Alt-F8, and Sid is on Ctrl-Alt-F1: they use those
   keystrokes to switch between their sessions).   How come the view in a
   VNC viewer connecting to x11vnc is either completely black or
   otherwise all messed up unless the X session x11vnc is attached to is
   in the active VC?

   This seems to have to do with how applications (the X server processes
   in this case) must "play nicely" if they are not on the active VC.
   That is, they should not read from the keyboard or mouse or manage the
   video display unless they have the active VC. Given that it appears
   the XGetImage() call must ultimately retrieve the framebuffer data
   from the video hardware itself, it would make sense x11vnc's polling
   wouldn't work unless the X session had active control of the VC.

   There does not seem to be an easy way to work around this. Even xwd(1)
   doesn't work in this case (try it). Something would need to be done at
   a lower level, say in the XFree86 X server. Also, using the XFree86
   Shadow Framebuffer (a copy of the video framebuffer is kept in main
   memory) does not appear to fix the problem.

   If no one is sitting at the workstation and you just want to remotely
   switch the VC over to the one associated with your X session (so
   x11vnc can poll it correctly), one can use the chvt(1) command, e.g.
   "chvt 7" for VC #7.


   Q-75: Can I use x11vnc to view my VMWare session remotely?

   Yes, since VMWare is an X application you can view it via x11vnc in
   the normal way.

   Note that VMWare has several viewing modes:
     * Normal X application window  (with window manager frame)
     * Quick-Switch mode  (with no window manager frame)
     * Fullscreen mode

   The way VMWare does Fullscreen mode on Linux is to display the Guest
   desktop in a separate Virtual Console (e.g. VC 8) (see [383]this FAQ
   on VC's for background). Unfortunately, this Fullscreen VC is not an X
   server. So x11vnc cannot access it (however, [384]see this for a
   possible partial workaround). x11vnc works fine with "Normal X
   application window" and "Quick-Switch mode" because these use X.

   One user reports he left his machine with VMWare in the Fullscreen
   mode, and even though his X session wasn't in the active VC, he could
   still connect x11vnc to the X session and pass the keystrokes Ctrl-Alt
   (typing "blind") to the VMWare X app. This induced VMWare to switch
   out of Fullscreen into Normal X mode and he could continue working in
   the Guest desktop remotely.

   Sometimes it is convenient (for performance, etc.) to start VMWare in
   its own X session using startx(1). This can be used to have a minimal
   window manger (e.g. twm or even no window manager), to improve
   response. One can also cut the display depth (e.g. to 16bpp) in this
   2nd X session to improve video performance. This 2nd X session
   emulates Fullscreen mode to some degree and can be viewed via x11vnc
   as long as the VMWare X session [385]is in the active VC.

   Also note that with a little bit of playing with "xwininfo -all
   -children" output one can extract the (non-toplevel) windowid of the
   of the Guest desktop only when VMWare is running as a normal X
   application. Then one can export just the guest desktop (i.e. without
   the VMWare menu buttons) by use of the [386]-id windowid option. The
   caveats are the X session VMWare is in must be in the active VC and
   the window must be fully visible, so this mode is not terribly
   convenient, but could be useful in some circumstances (e.g. running
   VMWare on a very powerful server machine in a server room that happens
   to have a video card, (but need not have a monitor, Keyboard or
   mouse)).


   Q-76: Can non-X devices (e.g. a raw framebuffer) be viewed and/or
   controlled by x11vnc?

   As of Apr/2005 in the libvncserver CVS there is rudimentary support
   for this. Two options were added: "-rawfb string" (to indicate the raw
   framembuffer and its parameters) and "-pipeinput cmd" (to provide an
   external program that will inject or otherwise process mouse and
   keystroke input).

   This non-X mode for x11vnc is experimental because it is so removed in
   scope from the intended usage of the tool. No attempt is made to make
   all of the other options consistent with non-X framebuffer polling. So
   all of the X-related options (e.g. -add_keysyms, -xkb) are just
   ignored or in the worst case will cause a crash. Be careful applying
   such an option via the command line or remote control.

   The format for the -rawfb string is:
    -rawfb <type>:<object>@<W>x<H>x<bpp>[:<R>/<G>/<B>][+<offset>]

   Some examples:
    -rawfb shm:210337933@800x600x32:ff/ff00/ff0000

    -rawfb map:/dev/fb0@1024x768x16

    -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232

    -rawfb file:/tmp/my.pnm@250x200x24+37

   So the type can be "shm" for shared memory objects, and "map" or
   "file" for file objects. "map" uses mmap(2) to map the file into
   memory and is preferred over "file" (that uses the slower lseek(2)
   access method). Only use file if map isn't working. BTW, "mmap" is an
   alias for "map" and if you do not supply a type and the file exists,
   map is assumed.

   Also, if the string is of the form "setup:cmd" then cmd is run and the
   first line of its output retrieved and used as the rawfb string. This
   allows initializing the device, determining WxHxB, etc.

   The object will be the numerical shared memory id for the case of shm.
   The idea here is some other program has created this shared memory
   segment and periodically updates it with new framebuffer data. x11vnc
   polls the area for changes. See shmat(2) and ipcs(8) for more info.
   The ipcs command will list current shared memory segments on the
   system.

   The object will be the path to the regular or character special file
   for the cases of map and file. The idea here is that in the case of a
   regular file some other program is writing/updating framebuffer image
   data to it. In the case of a character special (e.g. /dev/fb0) it is
   the kernel that is "updating" the framebuffer data.

   In all cases x11vnc needs to be told the width, height, and number of
   bits per pixel (bpp) of the framebuffer. This is the @WxHxB field. For
   the case of the Linux framebuffer device, /dev/fb0, the fbset(8) may
   be of use (but may not always be accurate for what is currently
   viewable). In general some guessing may be required, especially for
   the bpp.

   Based on the bpp x11vnc will try to guess the red, green, and blue
   masks (these indicate which bits correspond to each color). It if gets
   it wrong you can specify them manually via the optional ":R/G/B"
   field. E.g. ":0xff000/0x00ff00/0x0000ff" (this is the default for
   32bpp).

   Finally, the framebuffer may not begin at the beginning of the memory
   object, so use the optional "+offset" parameter to indicate where the
   framebuffer information starts. So as an example, the Xvfb virtual
   framebuffer has options -shmem and -fbdir for exporting its virtual
   screen to either shm or a mapped file. The format of these is XWD and
   so the initial header should be skipped. BTW, since XWD is not
   strictly RGB the view will only be approximate. Of course for the case
   of Xvfb x11vnc can poll it much better via the [387]X API, but you get
   the idea.

   By default in -rawfb mode x11vnc will actually close any X display it
   happened to open. This is basically to shake out bugs (e.g it will
   crash rather than mysteriously interacting with the X display). If you
   want x11vnc to keep the X display open while polling the raw
   framebuffer capitalize the type (i.e. "SHM:", "MAP:", or "FILE:").
   This could be convenient for keeping the remote control channel active
   (it uses X properties). The "-connect /path/to/file" mechanism could
   also be used for remote control to avoid the X property channel. Rare
   usage, but if you also supply -noviewonly in this mode then the mouse
   and keyboard input are still sent to the X display, presumably for
   doing something strange with /dev/fb...


   All of the above was just for viewing the raw framebuffer. That may be
   enough for certain applications of this feature (e.g. suppose a video
   camera mapped its framebuffer into memory). To handle the pointer and
   keyboard input from the viewer users the "-pipeinput cmd" option was
   added to indicate a helper program to process the user input. The
   input is streamed to it and looks something like this:
   Pointer 1 205 257 0 None
   Pointer 1 198 253 0 None
   Pointer 1 198 253 1 ButtonPress-1
   Pointer 1 198 253 0 ButtonRelease-1
   Pointer 1 198 252 0 None
   Keysym 1 1 119 w KeyPress
   Keysym 1 0 119 w KeyRelease
   Keysym 1 1 65288 BackSpace KeyPress
   Keysym 1 0 65288 BackSpace KeyRelease
   Keysym 1 1 112 p KeyPress
   Keysym 1 0 112 p KeyRelease

   Run "-pipeinput tee:/bin/cat" to get a description of the format. Note
   that the -pipeinput option is independent of -rawfb mode and so may
   have some other interesting uses. BTW, the "tee:" prefix means x11vnc
   will both process the user input and pipe it to the command. The
   default is to just pipe it to the -pipeinput command.

   Note the -pipeinput helper program could actually control the raw
   framebuffer. In the libvncserver CVS a simple example program
   x11vnc/misc/slide.pl is provided that demonstrates a simple jpeg
   "slideshow" application.

   The -pipeinput program is run with these environment variables set:
   X11VNC_PID, X11VNC_PROG, X11VNC_CMDLINE, X11VNC_RAWFB_STR to aid its
   knowing what is up.

   Another example provided in libvncserver CVS is a script to inject
   keystrokes into the Linux console (e.g. the virtual consoles:
   /dev/tty1, /dev/tty2, etc) in x11vnc/misc/vcinject.pl. It is based on
   the vncterm/LinuxVNC.c program also in the libvncserver CVS. So to
   view and interact with VC #2 (assuming it is the [388]active VC) one
   can run something like:
  x11vnc -rawfb map:/dev/fb0@1024x768x16 -pipeinput './vcinject.pl 2'

   This assumes your Linux framebuffer device (/dev/fb0) is properly
   configured. See fbset(8) and other documentation. Try
   "file:/dev/fb0@WxHxB" as a last resort.

   The above is just an example of what can be done. If you really want
   to view and interact with the Linux console it is better to use the
   more accurate and faster LinuxVNC program. The only advantage x11vnc
   -rawfb might have is that it can presumably allow interaction with a
   non-text application, e.g. one based on svgalib. For example the
   [389]VMWare Fullscreen mode is actually viewable under -rawfb. But
   this isn't much use until one figures out how to inject keystrokes and
   mouse events.

   The -rawfb and -pipeinput features are intended to help one creatively
   "get out of a jam" (say on a legacy or embedded device) where X is
   absent or doesn't work properly. Feedback and bug reports are welcome.
   For more control and less overhead use libvncserver in your own C
   program that passes the framebuffer to libvncserver.


   Q-77: I am using x11vnc where my local machine has "popup/hidden
   taskbars" (e.g. GNOME or MacOS X) and the remote display where x11vnc
   runs also has "popup/hidden taskbars" (e.g. GNOME). When I move the
   mouse to the edge of the screen where the popups happen, the taskbars
   interfere and fight with each other in strange ways. What can I do?

   Is there a way to temporarily disable one or both of these magic
   desktop taskbars? One x11vnc user suggests: it should be
   straightforward to right mouse click on the task bar panel, and
   uncheck "enable auto-hide" from the panel properties dialog box. This
   will make the panel always visible.

   [Misc: Clipboard, Beeps, Thanks, etc.]

   Q-78: Does the Clipboard/Selection get transferred between the
   vncviewer and the X display?

   As of Jan/2004 in the libvncserver CVS x11vnc supports the "CutText"
   part of the rfb protocol. Furthermore, x11vnc is able to hold the
   PRIMARY selection (Xvnc does not seem to do this). If you don't want
   the Clipboard/Selection exchanged use the [390]-nosel option. If you
   don't want the PRIMARY selection to be polled for changes use the
   [391]-noprimary option.

   You may need to watch out for desktop utilities such as KDE's
   "Klipper" that do odd things with the selection, clipboard, and
   cutbuffers.


   Q-79: Why don't I hear the "Beeps" in my X session (e.g. when typing
   tput bel in an xterm)?

   As of Dec/2003 in the libvncserver CVS "Beep" XBell events are tracked
   by default. The X server must support the XKEYBOARD extension (this is
   not on by default in Solaris, see Xserver(1) for how to turn it on via
   +kb), and so you won't hear them if the extension is not present.

   If you don't want to hear the beeps use the [392]-nobell option. If
   you want to hear the audio from the remote applications, consider
   trying a redirector such as esd.




    Contributions:

   Q-80: Thanks for your program and for your help! Can I make a
   donation?

   Please do (any amount is appreciated) and thank you for your support!
   Click on the PayPal button below for more info.
   Also, in general I always enjoy hearing from x11vnc users, how they
   use it, what new features they would like, etc.   Please send me an
   [393]email!

   [PayPal]

References

   1. http://www.karlrunge.com/x11vnc/index.html#faq
   2. http://www.karlrunge.com/x11vnc/index.html#downloading
   3. http://www.karlrunge.com/x11vnc/index.html#building
   4. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
   5. http://www.karlrunge.com/x11vnc/index.html#beta-test
   6. http://www.karlrunge.com/x11vnc/index.html#faq
   7. http://www.karlrunge.com/x11vnc/index.html#contact
   8. http://www.uk.research.att.com/vnc/
   9. http://www.realvnc.com/
  10. http://www.tightvnc.com/
  11. http://www.karlrunge.com/x11vnc/index.html#downloading
  12. http://www.tightvnc.com/download.html
  13. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
  14. http://www.karlrunge.com/x11vnc/index.html#faq-xperms
  15. http://www.karlrunge.com/x11vnc/index.html#faq-viewer-download
  16. http://www.sun.com/software/solaris/freeware/
  17. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
  18. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
  19. http://www.karlrunge.com/x11vnc/index.html#faq-service
  20. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  21. http://www.karlrunge.com/x11vnc/index.html#vnc_password_file
  22. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
  23. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
  24. http://www.karlrunge.com/x11vnc/index.html#tightvnc_via
  25. http://www.karlrunge.com/x11vnc/index.html#gateway_double_ssh
  26. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
  27. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
  28. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
  29. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
  30. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  31. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
  32. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
  33. http://www.karlrunge.com/x11vnc/index.html#faq-allow-opt
  34. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
  35. http://sourceforge.net/projects/libvncserver/
  36. http://sourceforge.net/project/showfiles.php?group_id=32584&package_id=119006&release_id=307884
  37. http://sourceforge.net/project/shownotes.php?group_id=32584&release_id=307884
  38. http://www.karlrunge.com/x11vnc/x11vnc-0.7.2.tar.gz
  39. http://www.karlrunge.com/x11vnc/index.html#faq-binaries
  40. http://www.tightvnc.com/download.html
  41. http://www.realvnc.com/download-free.html
  42. http://sourceforge.net/projects/cotvnc/
  43. http://www.karlrunge.com/x11vnc/rx11vnc
  44. http://www.karlrunge.com/x11vnc/rx11vnc.pl
  45. http://www.sunfreeware.com/
  46. http://www.karlrunge.com/x11vnc/index.html#faq-build
  47. ftp://ftp.uu.net/graphics/jpeg/
  48. http://www.gzip.org/zlib/
  49. http://www.sunfreeware.com/
  50. http://www.karlrunge.com/x11vnc/index.html#faq-solaris251build
  51. http://www.karlrunge.com/x11vnc/x11vnc-0.7.2beta.tar.gz
  52. http://www.karlrunge.com/x11vnc/bins
  53. mailto:x11vnc-beta@karlrunge.com
  54. http://www.karlrunge.com/x11vnc/next-rel.html
  55. http://www.karlrunge.com/x11vnc/index.html#faq-xdamage
  56. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
  57. http://www.karlrunge.com/x11vnc/index.html#wirecopyrect
  58. http://www.karlrunge.com/x11vnc/index.html#faq-scrollcopyrect
  59. http://www.karlrunge.com/x11vnc/beta-test-0.7.2.html
  60. mailto:x11vnc-beta@karlrunge.com
  61. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-solid
  62. http://www.tightvnc.com/
  63. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
  64. http://www.karlrunge.com/x11vnc/x11vnc_opts.html
  65. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  66. http://www.karlrunge.com/x11vnc/recurse_x11vnc.jpg
  67. http://wwws.sun.com/sunray/index.html
  68. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nap
  69. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
  70. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
  71. http://www.karlrunge.com/x11vnc/shm_clear
  72. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
  73. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
  74. mailto:xvml@karlrunge.com
  75. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
  76. http://www.karlrunge.com/x11vnc/index.html#faq-xperms
  77. http://www.karlrunge.com/x11vnc/index.html#faq-build
  78. http://www.karlrunge.com/x11vnc/index.html#faq-missing-xtest
  79. http://www.karlrunge.com/x11vnc/index.html#faq-solaris251build
  80. http://www.karlrunge.com/x11vnc/index.html#faq-binaries
  81. http://www.karlrunge.com/x11vnc/index.html#faq-viewer-download
  82. http://www.karlrunge.com/x11vnc/index.html#faq-cmdline-opts
  83. http://www.karlrunge.com/x11vnc/index.html#faq-config-file
  84. http://www.karlrunge.com/x11vnc/index.html#faq-quiet-bg
  85. http://www.karlrunge.com/x11vnc/index.html#faq-sigpipe
  86. http://www.karlrunge.com/x11vnc/index.html#faq-build-customizations
  87. http://www.karlrunge.com/x11vnc/index.html#faq-win2vnc
  88. http://www.karlrunge.com/x11vnc/index.html#faq-win2vnc-8bpp
  89. http://www.karlrunge.com/x11vnc/index.html#faq-8bpp
  90. http://www.karlrunge.com/x11vnc/index.html#faq-overlays
  91. http://www.karlrunge.com/x11vnc/index.html#faq-windowid
  92. http://www.karlrunge.com/x11vnc/index.html#faq-transients-id
  93. http://www.karlrunge.com/x11vnc/index.html#faq-24bpp
  94. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
  95. http://www.karlrunge.com/x11vnc/index.html#faq-xterminal-xauth
  96. http://www.karlrunge.com/x11vnc/index.html#faq-stop-bg
  97. http://www.karlrunge.com/x11vnc/index.html#faq-remote_control
  98. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
  99. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 100. http://www.karlrunge.com/x11vnc/index.html#faq-input-opt
 101. http://www.karlrunge.com/x11vnc/index.html#faq-forever-shared
 102. http://www.karlrunge.com/x11vnc/index.html#faq-allow-opt
 103. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
 104. http://www.karlrunge.com/x11vnc/index.html#faq-listen-interface
 105. http://www.karlrunge.com/x11vnc/index.html#faq-listen-localhost
 106. http://www.karlrunge.com/x11vnc/index.html#faq-ssh-unix
 107. http://www.karlrunge.com/x11vnc/index.html#faq-ssh-putty
 108. http://www.karlrunge.com/x11vnc/index.html#faq-accept-opt
 109. http://www.karlrunge.com/x11vnc/index.html#faq-unix-passwords
 110. http://www.karlrunge.com/x11vnc/index.html#faq-users-opt
 111. http://www.karlrunge.com/x11vnc/index.html#faq-blockdpy
 112. http://www.karlrunge.com/x11vnc/index.html#faq-gone-lock
 113. http://www.karlrunge.com/x11vnc/index.html#faq-service
 114. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 115. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 116. http://www.karlrunge.com/x11vnc/index.html#faq-java-http
 117. http://www.karlrunge.com/x11vnc/index.html#faq-reverse-connect
 118. http://www.karlrunge.com/x11vnc/index.html#faq-xvfb
 119. http://www.karlrunge.com/x11vnc/index.html#faq-headless
 120. http://www.karlrunge.com/x11vnc/index.html#faq-solshm
 121. http://www.karlrunge.com/x11vnc/index.html#faq-less-resource
 122. http://www.karlrunge.com/x11vnc/index.html#faq-more-resource
 123. http://www.karlrunge.com/x11vnc/index.html#faq-slow-link
 124. http://www.karlrunge.com/x11vnc/index.html#faq-xdamage
 125. http://www.karlrunge.com/x11vnc/index.html#faq-pointer-mode
 126. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 127. http://www.karlrunge.com/x11vnc/index.html#faq-scrollcopyrect
 128. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-shape
 129. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha
 130. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha-hacks
 131. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-arrow
 132. http://www.karlrunge.com/x11vnc/index.html#faq-cursor-positions
 133. http://www.karlrunge.com/x11vnc/index.html#faq-buttonmap-opt
 134. http://www.karlrunge.com/x11vnc/index.html#faq-altgr
 135. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless
 136. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 137. http://www.karlrunge.com/x11vnc/index.html#faq-repeated-keys
 138. http://www.karlrunge.com/x11vnc/index.html#faq-repeated-keys-still
 139. http://www.karlrunge.com/x11vnc/index.html#faq-remap-opt
 140. http://www.karlrunge.com/x11vnc/index.html#faq-sun-alt-meta
 141. http://www.karlrunge.com/x11vnc/index.html#faq-remap-button-click
 142. http://www.karlrunge.com/x11vnc/index.html#faq-scrollbars
 143. http://www.karlrunge.com/x11vnc/index.html#faq-scaling
 144. http://www.karlrunge.com/x11vnc/index.html#faq-xinerama
 145. http://www.karlrunge.com/x11vnc/index.html#faq-multi-screen
 146. http://www.karlrunge.com/x11vnc/index.html#faq-clip-screen
 147. http://www.karlrunge.com/x11vnc/index.html#faq-xrandr
 148. http://www.karlrunge.com/x11vnc/index.html#faq-black-screen
 149. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 150. http://www.karlrunge.com/x11vnc/index.html#faq-vmware
 151. http://www.karlrunge.com/x11vnc/index.html#faq-rawfb
 152. http://www.karlrunge.com/x11vnc/index.html#faq-hidden-taskbars
 153. http://www.karlrunge.com/x11vnc/index.html#faq-clipboard
 154. http://www.karlrunge.com/x11vnc/index.html#faq-beeps
 155. http://www.karlrunge.com/x11vnc/index.html#faq-thanks
 156. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display
 157. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 158. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 159. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-users
 160. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
 161. http://www.karlrunge.com/x11vnc/x11vnc_sunos4.html
 162. http://www.karlrunge.com/x11vnc/index.html#building
 163. http://www.karlrunge.com/x11vnc/index.html#faq-build
 164. http://packages.debian.org/x11vnc
 165. http://www.linuxpackages.net/search_view.php?by=name&name=x11vnc
 166. http://dag.wieers.com/packages/x11vnc/
 167. http://linux01.gwdg.de/~pbleser/rpm-navigation.php?cat=Network/x11vnc/
 168. http://www.sunfreeware.com/
 169. http://www.bell-labs.com/project/wwexptools/packages.html
 170. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
 171. http://www.karlrunge.com/x11vnc/bins
 172. http://www.tightvnc.com/download.html
 173. http://www.realvnc.com/download-free.html
 174. http://sourceforge.net/projects/cotvnc/
 175. http://www.karlrunge.com/x11vnc/x11vnc_opts.html
 176. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gui
 177. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-q
 178. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
 179. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-o
 180. http://www.karlrunge.com/x11vnc/index.html#solarisbuilding
 181. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nofb
 182. http://fredrik.hubbe.net/x2vnc.html
 183. http://www.hubbe.net/~hubbe/win2vnc.html
 184. http://www.deboer.gmxhome.de/
 185. http://sourceforge.net/projects/win2vnc/
 186. http://fredrik.hubbe.net/x2vnc.html
 187. http://freshmeat.net/projects/x2x/
 188. http://ftp.digital.com/pub/Digital/SRC/x2x/
 189. http://zapek.com/software/zvnc/
 190. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-visual
 191. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-flashcmap
 192. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-notruecolor
 193. http://www.karlrunge.com/x11vnc/index.html#faq-8bpp
 194. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 195. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 196. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 197. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 198. http://www.karlrunge.com/x11vnc/index.html#faq-overlays
 199. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 200. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-sid
 201. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-display
 202. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 203. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-flipbyteorder
 204. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 205. http://www.karlrunge.com/x11vnc/index.html#xauth_pain
 206. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
 207. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remote
 208. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-query
 209. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
 210. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-bg
 211. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clear_mods
 212. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clear_keys
 213. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remote
 214. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-query
 215. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gui
 216. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-storepasswd
 217. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 218. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 219. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-viewpasswd
 220. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwd
 221. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
 222. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 223. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-input
 224. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-forever
 225. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-shared
 226. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 227. http://www.karlrunge.com/x11vnc/index.html#faq-passwd
 228. http://www.karlrunge.com/x11vnc/index.html#faq-passwdfile
 229. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 230. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 231. http://www.karlrunge.com/x11vnc/index.html#faq-tcp_wrappers
 232. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 233. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-listen
 234. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 235. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 236. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 237. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 238. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-listen
 239. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-allow
 240. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 241. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 242. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 243. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 244. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbauth
 245. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-passwdfile
 246. http://www.karlrunge.com/x11vnc/index.html#gateway_double_ssh
 247. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 248. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
 249. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 250. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-viewonly
 251. ftp://ftp.x.org/
 252. http://www.karlrunge.com/x11vnc/dtVncPopup
 253. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 254. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-localhost
 255. http://www.karlrunge.com/x11vnc/index.html#tunnelling
 256. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 257. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-users
 258. http://www.karlrunge.com/x11vnc/blockdpy.c
 259. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-accept
 260. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 261. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-gone
 262. http://www.karlrunge.com/x11vnc/index.html#display-manager-continuously
 263. http://www.karlrunge.com/x11vnc/index.html#faq-inetd
 264. http://www.karlrunge.com/x11vnc/index.html#x11vnc_loop
 265. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 266. http://www.karlrunge.com/x11vnc/index.html#dtlogin_solaris
 267. http://www.jirka.org/gdm-documentation/x241.html
 268. http://www.karlrunge.com/x11vnc/x11vnc_loop
 269. http://www.karlrunge.com/x11vnc/index.html#faq-xterminal-xauth
 270. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-inetd
 271. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-q
 272. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-auth
 273. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-httpdir
 274. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-connect
 275. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-vncconnect
 276. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 277. http://www.karlrunge.com/x11vnc/index.html#display-manager-continuously
 278. http://www.karlrunge.com/x11vnc/shm_clear
 279. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 280. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 281. http://www.karlrunge.com/x11vnc/index.html#faq-noshm
 282. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nap
 283. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
 284. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 285. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fs
 286. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-threads
 287. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-defer
 288. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 289. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-solid
 290. http://www.tightvnc.com/
 291. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nodragging
 292. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-progressive
 293. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fs
 294. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wait
 295. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-defer
 296. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 297. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nosel
 298. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursor
 299. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorpos
 300. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 301. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xd_area
 302. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xd_mem
 303. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noxdamage
 304. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 305. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 306. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 307. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nodragging
 308. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-pointer_mode
 309. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-threads
 310. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 311. http://www.karlrunge.com/x11vnc/index.html#faq-scrollcopyrect
 312. http://www.karlrunge.com/x11vnc/index.html#faq-pointer-mode
 313. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 314. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 315. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 316. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 317. http://www.karlrunge.com/x11vnc/index.html#fb_read_slow
 318. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 319. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wireframe
 320. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-wirecopyrect
 321. http://www.karlrunge.com/x11vnc/index.html#faq-wireframe
 322. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-fixscreen
 323. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scr_skip
 324. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale
 325. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scrollcopyrect
 326. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
 327. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursor
 328. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-overlay
 329. http://www.karlrunge.com/x11vnc/index.html#the-overlay-mode
 330. http://www.karlrunge.com/x11vnc/index.html#solaris10-build
 331. http://www.karlrunge.com/x11vnc/index.html#faq-xfixes-alpha-hacks
 332. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alphacut
 333. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alphafrac
 334. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-alpharemove
 335. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorshape
 336. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noalphablend
 337. http://www.tightvnc.com/
 338. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursor
 339. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-cursorpos
 340. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorpos
 341. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nocursorshape
 342. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-buttonmap
 343. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_pointer
 344. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-buttonmap
 345. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 346. http://www.karlrunge.com/x11vnc/index.html#faq-greaterless
 347. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 348. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_keyboard
 349. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 350. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 351. http://www.karlrunge.com/x11vnc/index.html#faq-xkbmodtweak
 352. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-debug_keyboard
 353. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-modtweak
 354. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xkb
 355. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-skip_keycodes
 356. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 357. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 358. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 359. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-add_keysyms
 360. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-norepeat
 361. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-norepeat
 362. http://www.karlrunge.com/x11vnc/index.html#faq-display-manager
 363. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 364. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 365. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 366. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-remap
 367. http://www.karlrunge.com/x11vnc/index.html#faq-scaling
 368. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale
 369. http://www.cus.cam.ac.uk/~ssb22/source/vnc-magnification.html
 370. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-rfbport
 371. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-scale_cursor
 372. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-blackout
 373. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xinerama
 374. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xwarppointer
 375. http://www.karlrunge.com/x11vnc/index.html#faq-solshm
 376. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-onetile
 377. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noshm
 378. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-clip
 379. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 380. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 381. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-xrandr
 382. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-padgeom
 383. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 384. http://www.karlrunge.com/x11vnc/index.html#faq-rawfb
 385. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 386. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-id
 387. http://www.karlrunge.com/x11vnc/index.html#faq-xvfb
 388. http://www.karlrunge.com/x11vnc/index.html#faq-linuxvc
 389. http://www.karlrunge.com/x11vnc/index.html#faq-vmware
 390. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nosel
 391. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-noprimary
 392. http://www.karlrunge.com/x11vnc/x11vnc_opts.html#opt-nobell
 393. mailto:xvml@karlrunge.com


=======================================================================
http://www.karlrunge.com/x11vnc/x11vnc_opts.html:

     _________________________________________________________________

x11vnc: a VNC server for real X displays

   Here are all of x11vnc command line options:
% x11vnc -opts      (see below for -help long descriptions)

x11vnc: allow VNC connections to real X11 displays. 0.7.2 lastmod: 2005-06-21

x11vnc options:
  -display disp            -auth file             
  -id windowid             -sid windowid          
  -clip WxH+X+Y            -flashcmap             
  -shiftcmap n             -notruecolor           
  -visual n                -overlay               
  -overlay_nocursor        -scale fraction        
  -scale_cursor frac       -viewonly              
  -shared                  -once                  
  -forever                 -timeout n             
  -inetd                   -http                  
  -connect string          -vncconnect            
  -novncconnect            -allow host1[,host2..] 
  -localhost               -nolookup              
  -input string            -viewpasswd string     
  -passwdfile filename     -storepasswd pass file 
  -accept string           -gone string           
  -users list              -noshm                 
  -flipbyteorder           -onetile               
  -solid [color]           -blackout string       
  -xinerama                -xtrap                 
  -xrandr [mode]           -padgeom WxH           
  -o logfile               -flag file             
  -rc filename             -norc                  
  -h, -help                -?, -opts              
  -V, -version             -dbg                   
  -q                       -bg                    
  -modtweak                -nomodtweak            
  -xkb                     -noxkb                 
  -skip_keycodes string    -skip_dups             
  -noskip_dups             -add_keysyms           
  -noadd_keysyms           -clear_mods            
  -clear_keys              -remap string          
  -norepeat                -repeat                
  -nofb                    -nobell                
  -nosel                   -noprimary             
  -seldir string           -cursor [mode]         
  -nocursor                -arrow n               
  -noxfixes                -alphacut n            
  -alphafrac fraction      -alpharemove           
  -noalphablend            -nocursorshape         
  -cursorpos               -nocursorpos           
  -xwarppointer            -buttonmap string      
  -nodragging              -wireframe [str]       
  -nowireframe             -wirecopyrect mode     
  -nowirecopyrect          -debug_wireframe       
  -scrollcopyrect mode     -noscrollcopyrect      
  -scr_area n              -scr_skip list         
  -scr_inc list            -scr_keys list         
  -scr_term list           -scr_keyrepeat lo-hi   
  -scr_parms string        -fixscreen string      
  -debug_scroll            -noxrecord             
  -pointer_mode n          -input_skip n          
  -speeds rd,bw,lat        -debug_pointer         
  -debug_keyboard          -defer time            
  -wait time               -wait_ui factor        
  -nowait_bog              -readtimeout n         
  -nap                     -nonap                 
  -sb time                 -noxdamage             
  -xd_area A               -xd_mem f              
  -sigpipe string          -threads               
  -nothreads               -fs f                  
  -gaps n                  -grow n                
  -fuzz n                  -debug_tiles           
  -snapfb                  -rawfb string          
  -pipeinput cmd           -gui [gui-opts]        
  -remote command          -query variable        
  -sync                    -noremote              
  -yesremote               -unsafe                
  -safer                   -privremote            
  -nocmds                  -deny_all              


libvncserver options:
-rfbport port          TCP port for RFB protocol
-rfbwait time          max time in ms to wait for RFB client
-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
-passwd plain-password use authentication 
                       (use plain-password as password, USE AT YOUR RISK)
-deferupdate time      time in ms to defer updates (default 40)
-desktop name          VNC desktop name (default "LibVNCServer")
-alwaysshared          always treat new clients as shared
-nevershared           never treat new clients as shared
-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
-httpdir dir-path      enable http server using dir-path home
-httpport portnum      use portnum for http connection
-enablehttpproxy       enable http proxy support
-progressive height    enable progressive updating for slow links
-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.



% x11vnc -help

x11vnc: allow VNC connections to real X11 displays. 0.7.2 lastmod: 2005-06-21

Typical usage is:

   Run this command in a shell on the remote machine "far-host"
   with X session you wish to view:

       x11vnc -display :0

   Then run this in another window on the machine you are sitting at:

       vncviewer far-host:0

Once x11vnc establishes connections with the X11 server and starts listening
as a VNC server it will print out a string: PORT=XXXX where XXXX is typically
5900 (the default VNC server port).  One would next run something like
this on the local machine: "vncviewer hostname:N" where "hostname" is
the name of the machine running x11vnc and N is XXXX - 5900, i.e. usually
"vncviewer hostname:0".

By default x11vnc will not allow the screen to be shared and it will exit
as soon as the client disconnects.  See -shared and -forever below to override
these protections.  See the FAQ for details how to tunnel the VNC connection
through an encrypted channel such as ssh(1).  In brief:

       ssh -L 5900:localhost:5900 far-host 'x11vnc -localhost -display :0'

       vncviewer -encodings 'copyrect tight zrle hextile' localhost:0

For additional info see: http://www.karlrunge.com/x11vnc/
                    and  http://www.karlrunge.com/x11vnc/#faq


Rudimentary config file support: if the file $HOME/.x11vncrc exists then each
line in it is treated as a single command line option.  Disable with -norc.
For each option name, the leading character "-" is not required.  E.g. a
line that is either "forever" or "-forever" may be used and are equivalent.
Likewise "wait 100" or "-wait 100" are acceptable and equivalent lines.
The "#" character comments out to the end of the line in the usual way.
Leading and trailing whitespace is trimmed off.  Lines may be continued with
a "\" as the last character of a line (it becomes a space character).

Options:

-display disp          X11 server display to connect to, usually :0.  The X
                       server process must be running on same machine and
                       support MIT-SHM.  Equivalent to setting the DISPLAY
                       environment variable to "disp".
-auth file             Set the X authority file to be "file", equivalent to
                       setting the XAUTHORITY environment variable to "file"
                       before startup.  Same as -xauth file.  See Xsecurity(7),
                       xauth(1) man pages for more info.

-id windowid           Show the window corresponding to "windowid" not
                       the entire display.  New windows like popup menus,
                       transient toplevels, etc, may not be seen or may be
                       clipped.  Disabling SaveUnders or BackingStore in the
                       X server may help show them.  x11vnc may crash if the
                       window is initially partially obscured, changes size,
                       is iconified, etc.  Some steps are taken to avoid this
                       and the -xrandr mechanism is used to track resizes.  Use
                       xwininfo(1) to get the window id, or use "-id pick"
                       to have x11vnc run xwininfo(1) for you and extract
                       the id.  The -id option is useful for exporting very
                       simple applications (e.g. the current view on a webcam).
-sid windowid          As -id, but instead of using the window directly it
                       shifts a root view to it: this shows SaveUnders menus,
                       etc, although they will be clipped if they extend beyond
                       the window.
-clip WxH+X+Y          Only show the sub-region of the full display that
                       corresponds to the rectangle with size WxH and offset
                       +X+Y.  The VNC display has size WxH (i.e. smaller than
                       the full display).  This also works for -id/-sid mode
                       where the offset is relative to the upper left corner
                       of the selected window.

-flashcmap             In 8bpp indexed color, let the installed colormap flash
                       as the pointer moves from window to window (slow).
-shiftcmap n           Rare problem, but some 8bpp displays use less than 256
                       colorcells (e.g. 16-color grayscale, perhaps the other
                       bits are used for double buffering) *and* also need to
                       shift the pixels values away from 0, .., ncells.  "n"
                       indicates the shift to be applied to the pixel values.
                       To see the pixel values set DEBUG_CMAP=1 to print out
                       a colormap histogram.  Example: -shiftcmap 240
-notruecolor           For 8bpp displays, force indexed color (i.e. a colormap)
                       even if it looks like 8bpp TrueColor (rare problem).
-visual n              Experimental option: probably does not do what you
                       think.  It simply *forces* the visual used for the
                       framebuffer; this may be a bad thing... (e.g. messes
                       up colors or cause a crash). It is useful for testing
                       and for some workarounds.  n may be a decimal number,
                       or 0x hex.  Run xdpyinfo(1) for the values.  One may
                       also use "TrueColor", etc. see <X11/X.h> for a list.
                       If the string ends in ":m" then for better or for
                       worse the visual depth is forced to be m.

-overlay               Handle multiple depth visuals on one screen, e.g. 8+24
                       and 24+8 overlay visuals (the 32 bits per pixel are
                       packed with 8 for PseudoColor and 24 for TrueColor).

                       Currently -overlay only works on Solaris via
                       XReadScreen(3X11) and IRIX using XReadDisplay(3).
                       On Solaris there is a problem with image "bleeding"
                       around transient popup menus (but not for the menu
                       itself): a workaround is to disable SaveUnders
                       by passing the "-su" argument to Xsun (in
                       /etc/dt/config/Xservers).  Also note that the mouse
                       cursor shape is exactly correct in this mode.

                       Use -overlay as a workaround for situations like these:
                       Some legacy applications require the default visual to
                       be 8bpp (8+24), or they will use 8bpp PseudoColor even
                       when the default visual is depth 24 TrueColor (24+8).
                       In these cases colors in some windows will be messed
                       up in x11vnc unless -overlay is used.  Another use of
                       -overlay is to enable showing the exact mouse cursor
                       shape (details below).

                       Under -overlay, performance will be somewhat degraded
                       due to the extra image transformations required.
                       For optimal performance do not use -overlay, but rather
                       configure the X server so that the default visual is
                       depth 24 TrueColor and try to have all apps use that
                       visual (e.g. some apps have -use24 or -visual options).
-overlay_nocursor      Sets -overlay, but does not try to draw the exact mouse
                       cursor shape using the overlay mechanism.

-scale fraction        Scale the framebuffer by factor "fraction".  Values
                       less than 1 shrink the fb, larger ones expand it.  Note:
                       image may not be sharp and response may be slower.
                       If "fraction" contains a decimal point "." it
                       is taken as a floating point number, alternatively
                       the notation "m/n" may be used to denote fractions
                       exactly, e.g. -scale 2/3

                       Scaling Options: can be added after "fraction" via
                       ":", to supply multiple ":" options use commas.
                       If you just want a quick, rough scaling without
                       blending, append ":nb" to "fraction" (e.g. -scale
                       1/3:nb).  No blending is the default for 8bpp indexed
                       color, to force blending for this case use ":fb".

                       To disable -scrollcopyrect and -wirecopyrect under
                       -scale use ":nocr".  If you need to to enable them use
                       ":cr" or specify them explicitly on the command line.
                       If a slow link is detected, ":nocr" may be applied
                       automatically.  Default: :cr

                       More esoteric options: for compatibility with vncviewers
                       the scaled width is adjusted to be a multiple of 4:
                       to disable this use ":n4".  ":in" use interpolation
                       scheme even when shrinking, ":pad", pad scaled width
                       and height to be multiples of scaling denominator
                       (e.g. 3 for 2/3).

-scale_cursor frac     By default if -scale is supplied the cursor shape is
                       scaled by the same factor.  Depending on your usage,
                       you may want to scale the cursor independently of the
                       screen or not at all.  If you specify -scale_cursor
                       the cursor will be scaled by that factor.  When using
                       -scale mode to keep the cursor at its "natural" size
                       use "-scale_cursor 1".  Most of the ":" scaling
                       options apply here as well.

-viewonly              All VNC clients can only watch (default off).
-shared                VNC display is shared, i.e. more than one viewer can
                       connect at the same time (default off).
-once                  Exit after the first successfully connected viewer
                       disconnects, opposite of -forever. This is the Default.
-forever               Keep listening for more connections rather than exiting
                       as soon as the first client(s) disconnect. Same as -many
-timeout n             Exit unless a client connects within the first n seconds
                       of startup.
-inetd                 Launched by inetd(1): stdio instead of listening socket.
                       Note: if you are not redirecting stderr to a log file
                       (via shell 2> or -o option) you must also specify the -q
                       option, otherwise the stderr goes to the viewer which
                       will cause it to abort.  Specifying both -inetd and -q
                       and no -o will automatically close the stderr.
-http                  Instead of using -httpdir (see below) to specify
                       where the Java vncviewer applet is, have x11vnc try
                       to *guess* where the directory is by looking relative
                       to the program location and in standard locations
                       (/usr/local/share/x11vnc/classes, etc).
-connect string        For use with "vncviewer -listen" reverse connections.
                       If "string" has the form "host" or "host:port"
                       the connection is made once at startup.  Use commas
                       for a list of host's and host:port's.

                       If "string" contains "/" it is instead interpreted
                       as a file to periodically check for new hosts.
                       The first line is read and then the file is truncated.
                       Be careful for this usage mode if x11vnc is running as
                       root (e.g. via inetd(1) or gdm(1)).
-vncconnect            Monitor the VNC_CONNECT X property set by the standard
-novncconnect          VNC program vncconnect(1).  When the property is
                       set to "host" or "host:port" establish a reverse
                       connection.  Using xprop(1) instead of vncconnect may
                       work (see the FAQ).  The -remote control mechanism also
                       uses this VNC_CONNECT channel.  Default: -vncconnect

-allow host1[,host2..] Only allow client connections from hosts matching
                       the comma separated list of hostnames or IP addresses.
                       Can also be a numerical IP prefix, e.g. "192.168.100."
                       to match a simple subnet, for more control build
                       libvncserver with libwrap support (See the FAQ).  If the
                       list contains a "/" it instead is a interpreted as a
                       file containing addresses or prefixes that is re-read
                       each time a new client connects.  Lines can be commented
                       out with the "#" character in the usual way.
-localhost             Same as "-allow 127.0.0.1".

                       Note: if you want to restrict which network interface
                       x11vnc listens on, see the -listen option below.
                       E.g. "-listen localhost" or "-listen 192.168.3.21".
                       As a special case, the option "-localhost" implies
                       "-listen localhost".

                       For non-localhost -listen usage, if you use the remote
                       control mechanism (-R) to change the -listen interface
                       you may need to manually adjust the -allow list (and
                       vice versa) to avoid situations where no connections
                       (or too many) are allowed.

-nolookup              Do not use gethostbyname() or gethostbyaddr() to look up
                       host names or IP numbers.  Use this if name resolution
                       is incorrectly set up and leads to long pauses as name
                       lookup times out, etc.

-input string          Fine tuning of allowed user input.  If "string" does
                       not contain a comma "," the tuning applies only to
                       normal clients.  Otherwise the part before "," is
                       for normal clients and the part after for view-only
                       clients.  "K" is for Keystroke input, "M" for
                       Mouse-motion input, and "B" for Button-click input.
                       Their presence in the string enables that type of input.
                       E.g. "-input M" means normal users can only move
                       the mouse and  "-input KMB,M" lets normal users do
                       anything and enables view-only users to move the mouse.
                       This option is ignored when a global -viewonly is in
                       effect (all input is discarded).
-viewpasswd string     Supply a 2nd password for view-only logins.  The -passwd
                       (full-access) password must also be supplied.
-passwdfile filename   Specify libvncserver -passwd via the first line of the
                       file "filename" instead of via command line (where
                       others might see it via ps(1)).  If a second non blank
                       line exists in the file it is taken as a view-only
                       password (i.e. -viewpasswd) To supply an empty password
                       for either field the string "__EMPTY__" may be used.
                       Note: -passwdfile is a simple plaintext passwd, see
                       also -rfbauth and -storepasswd below for obfuscated
                       VNC password files.  Neither file should be readable
                       by others.
-storepasswd pass file Store password "pass" as the VNC password in the
                       file "file".  Once the password is stored the
                       program exits.  Use the password via "-rfbauth file"

-accept string         Run a command (possibly to prompt the user at the
                       X11 display) to decide whether an incoming client
                       should be allowed to connect or not.  "string" is
                       an external command run via system(3) or some special
                       cases described below.  Be sure to quote "string"
                       if it contains spaces, shell characters, etc.  If the
                       external command returns 0 the client is accepted,
                       otherwise the client is rejected.  See below for an
                       extension to accept a client view-only.

                       If x11vnc is running as root (say from inetd(1) or from
                       display managers xdm(1), gdm(1), etc), think about the
                       security implications carefully before supplying this
                       option (likewise for the -gone option).

                       Environment: The RFB_CLIENT_IP environment variable will
                       be set to the incoming client IP number and the port
                       in RFB_CLIENT_PORT (or -1 if unavailable).  Similarly,
                       RFB_SERVER_IP and RFB_SERVER_PORT (the x11vnc side
                       of the connection), are set to allow identification
                       of the tcp virtual circuit.  The x11vnc process
                       id will be in RFB_X11VNC_PID, a client id number in
                       RFB_CLIENT_ID, and the number of other connected clients
                       in RFB_CLIENT_COUNT.  RFB_MODE will be "accept"

                       If "string" is "popup" then a builtin popup window
                       is used.  The popup will time out after 120 seconds,
                       use "popup:N" to modify the timeout to N seconds
                       (use 0 for no timeout)

                       If "string" is "xmessage" then an xmessage(1)
                       invocation is used for the command.  xmessage must be
                       installed on the machine for this to work.

                       Both "popup" and "xmessage" will present an option
                       for accepting the client "View-Only" (the client
                       can only watch).  This option will not be presented if
                       -viewonly has been specified, in which case the entire
                       display is view only.

                       If the user supplied command is prefixed with something
                       like "yes:0,no:*,view:3 mycommand ..." then this
                       associates the numerical command return code with
                       the actions: accept, reject, and accept-view-only,
                       respectively.  Use "*" instead of a number to indicate
                       the default action (in case the command returns an
                       unexpected value).  E.g. "no:*" is a good choice.

                       Note that x11vnc blocks while the external command
                       or popup is running (other clients may see no updates
                       during this period).

                       More -accept tricks: use "popupmouse" to only allow
                       mouse clicks in the builtin popup to be recognized.
                       Similarly use "popupkey" to only recognize
                       keystroke responses.  These are to help avoid the
                       user accidentally accepting a client by typing or
                       clicking. All 3 of the popup keywords can be followed
                       by +N+M to supply a position for the popup window.
                       The default is to center the popup window.
-gone string           As -accept, except to run a user supplied command when
                       a client goes away (disconnects).  RFB_MODE will be
                       set to "gone" and the other RFB_* variables are as
                       in -accept.  Unlike -accept, the command return code
                       is not interpreted by x11vnc.  Example: -gone 'xlock &'

-users list            If x11vnc is started as root (say from inetd(1) or from
                       display managers xdm(1), gdm(1), etc), then as soon
                       as possible after connections to the X display are
                       established try to switch to one of the users in the
                       comma separated "list".  If x11vnc is not running as
                       root this option is ignored.

                       Why use this option?  In general it is not needed since
                       x11vnc is already connected to the X display and can
                       perform its primary functions.  The option was added
                       to make some of the *external* utility commands x11vnc
                       occasionally runs work properly.  In particular under
                       GNOME and KDE to implement the "-solid color" feature
                       external commands (gconftool-2 and dcop) must be run
                       as the user owning the desktop session.  Since this
                       option switches userid it also affects the userid used
                       to run the processes for the -accept and -gone options.
                       It also affects the ability to read files for options
                       such as -connect, -allow, and -remap.  Note that the
                       -connect file is also sometimes written to.

                       So be careful with this option since in many situations
                       its use can decrease security.

                       The switch to a user will only take place if the
                       display can still be successfully opened as that user
                       (this is primarily to try to guess the actual owner
                       of the session). Example: "-users fred,wilma,betty".
                       Note that a malicious user "barney" by quickly using
                       "xhost +" when logging in may get x11vnc to switch
                       to user "fred".  What happens next?

                       Under display managers it may be a long time before
                       the switch succeeds (i.e. a user logs in).  To make
                       it switch immediately regardless if the display
                       can be reopened prefix the username with the "+"
                       character. E.g. "-users +bob" or "-users +nobody".
                       The latter (i.e. switching immediately to user
                       "nobody") is probably the only use of this option
                       that increases security.

                       To immediately switch to a user *before* connections
                       to the X display are made or any files opened use the
                       "=" character: "-users =bob".  That user needs to
                       be able to open the X display of course.

                       The special user "guess=" means to examine the utmpx
                       database (see who(1)) looking for a user attached to
                       the display number (from DISPLAY or -display option)
                       and try him/her.  To limit the list of guesses, use:
                       "-users guess=bob,betty".

                       Even more sinister is the special user "lurk=" that
                       means to try to guess the DISPLAY from the utmpx login
                       database as well.  So it "lurks" waiting for anyone
                       to log into an X session and then connects to it.
                       Specify a list of users after the = to limit which
                       users will be tried.  To enable a different searching
                       mode, if the first user in the list is something like
                       ":0" or ":0-2" that indicates a range of DISPLAY
                       numbers that will be tried (regardless of whether
                       they are in the utmpx database) for all users that
                       are logged in.  Examples: "-users lurk=" and also
                       "-users lurk=:0-1,bob,mary"

                       Be especially careful using the "guess=" and "lurk="
                       modes.  They are not recommended for use on machines
                       with untrustworthy local users.

-noshm                 Do not use the MIT-SHM extension for the polling.
                       Remote displays can be polled this way: be careful this
                       can use large amounts of network bandwidth.  This is
                       also of use if the local machine has a limited number
                       of shm segments and -onetile is not sufficient.
-flipbyteorder         Sometimes needed if remotely polled host has different
                       endianness.  Ignored unless -noshm is set.
-onetile               Do not use the new copy_tiles() framebuffer mechanism,
                       just use 1 shm tile for polling.  Limits shm segments
                       used to 3.

-solid [color]         To improve performance, when VNC clients are connected
                       try to change the desktop background to a solid color.
                       The [color] is optional: the default color is "cyan4".
                       For a different one specify the X color (rgb.txt name,
                       e.g. "darkblue" or numerical "#RRGGBB").

                       Currently this option only works on GNOME, KDE, CDE,
                       and classic X (i.e. with the background image on the
                       root window).  The "gconftool-2" and "dcop" external
                       commands are run for GNOME and KDE respectively.
                       Other desktops won't work, e.g. Xfce (send us the
                       corresponding commands if you find them).  If x11vnc is
                       running as root (inetd(1) or gdm(1)), the -users option
                       may be needed for GNOME and KDE.  If x11vnc guesses
                       your desktop incorrectly, you can force it by prefixing
                       color with "gnome:", "kde:", "cde:" or "root:".
-blackout string       Black out rectangles on the screen. "string" is a
                       comma separated list of WxH+X+Y type geometries for
                       each rectangle.
-xinerama              If your screen is composed of multiple monitors
                       glued together via XINERAMA, and that screen is
                       non-rectangular this option will try to guess the
                       areas to black out (if your system has libXinerama).

                       In general on XINERAMA displays you may need to use the
                       -xwarppointer option if the mouse pointer misbehaves.

-xtrap                 Use the DEC-XTRAP extension for keystroke and mouse
                       input insertion.  For use on legacy systems, e.g. X11R5,
                       running an incomplete or missing XTEST extension.
                       By default DEC-XTRAP will be used if XTEST server grab
                       control is missing, use -xtrap to do the keystroke and
                       mouse insertion via DEC-XTRAP as well.

-xrandr [mode]         If the display supports the XRANDR (X Resize, Rotate
                       and Reflection) extension, and you expect XRANDR events
                       to occur to the display while x11vnc is running, this
                       options indicates x11vnc should try to respond to
                       them (as opposed to simply crashing by assuming the
                       old screen size).  See the xrandr(1) manpage and run
                       'xrandr -q' for more info.  [mode] is optional and
                       described below.

                       Since watching for XRANDR events and trapping errors
                       increases polling overhead, only use this option if
                       XRANDR changes are expected.  For example on a rotatable
                       screen PDA or laptop, or using a XRANDR-aware Desktop
                       where you resize often.  It is best to be viewing with a
                       vncviewer that supports the NewFBSize encoding, since it
                       knows how to react to screen size changes.  Otherwise,
                       libvncserver tries to do so something reasonable for
                       viewers that cannot do this (portions of the screen
                       may be clipped, unused, etc).

                       "mode" defaults to "resize", which means create a
                       new, resized, framebuffer and hope all viewers can cope
                       with the change.  "newfbsize" means first disconnect
                       all viewers that do not support the NewFBSize VNC
                       encoding, and then resize the framebuffer.  "exit"
                       means disconnect all viewer clients, and then terminate
                       x11vnc.
-padgeom WxH           Whenever a new vncviewer connects, the framebuffer is
                       replaced with a fake, solid black one of geometry WxH.
                       Shortly afterwards the framebuffer is replaced with the
                       real one.  This is intended for use with vncviewers
                       that do not support NewFBSize and one wants to make
                       sure the initial viewer geometry will be big enough
                       to handle all subsequent resizes (e.g. under -xrandr,
                       -remote id:windowid, rescaling, etc.)

-o logfile             Write stderr messages to file "logfile" instead of
                       to the terminal.  Same as "-logfile file".  To append
                       to the file use "-oa file" or "-logappend file".
-flag file             Write the "PORT=NNNN" (e.g. PORT=5900) string to
                       "file" in addition to stdout.  This option could be
                       useful by wrapper script to detect when x11vnc is ready.

-rc filename           Use "filename" instead of $HOME/.x11vncrc for rc file.
-norc                  Do not process any .x11vncrc file for options.

-h, -help              Print this help text.
-?, -opts              Only list the x11vnc options.
-V, -version           Print program version and last modification date.

-dbg                   instead of exiting after cleaning up, run a simple
                       "debug crash shell" when fatal errors are trapped.

-q                     Be quiet by printing less informational output to
                       stderr.  Same as -quiet.
-bg                    Go into the background after screen setup.  Messages to
                       stderr are lost unless -o logfile is used.  Something
                       like this could be useful in a script:
                         port=`ssh $host "x11vnc -display :0 -bg" | grep PORT`
                         port=`echo "$port" | sed -e 's/PORT=//'`
                         port=`expr $port - 5900`
                         vncviewer $host:$port

-modtweak              Option -modtweak automatically tries to adjust the AltGr
-nomodtweak            and Shift modifiers for differing language keyboards
                       between client and host.  Otherwise, only a single key
                       press/release of a Keycode is simulated (i.e. ignoring
                       the state of the modifiers: this usually works for
                       identical keyboards).  Also useful in resolving cases
                       where a Keysym is bound to multiple keys (e.g. "<" + ">"
                       and "," + "<" keys).  Default: -modtweak
-xkb                   When in modtweak mode, use the XKEYBOARD extension (if
-noxkb                 the X display supports it) to do the modifier tweaking.
                       This is powerful and should be tried if there are still
                       keymapping problems when using -modtweak by itself.
                       The default is to check whether some common keysyms,
                       e.g. !, @, [, are only accessible via -xkb mode and if
                       so then automatically enable the mode.  To disable this
                       automatic detection use -noxkb.
-skip_keycodes string  Ignore the comma separated list of decimal keycodes.
                       Perhaps these are keycodes not on your keyboard but
                       your X server thinks exist.  Currently only applies
                       to -xkb mode.  Use this option to help x11vnc in the
                       reverse problem it tries to solve: Keysym -> Keycode(s)
                       when ambiguities exist (more than one Keycode per
                       Keysym).  Run 'xmodmap -pk' to see your keymapping.
                       Example: "-skip_keycodes 94,114"
-skip_dups             Some VNC viewers send impossible repeated key events,
-noskip_dups           e.g. key-down, key-down, key-up, key-up all for the same
                       key, or 20 downs in a row for the same modifier key!
                       Setting -skip_dups means to skip these duplicates and
                       just process the first event. Note: some VNC viewers
                       assume they can send down's without the corresponding
                       up's and so you should not set this option for
                       these viewers (symptom: some keys do not autorepeat)
                       Default: -noskip_dups
-add_keysyms           If a Keysym is received from a VNC viewer and
-noadd_keysyms         that Keysym does not exist in the X server, then
                       add the Keysym to the X server's keyboard mapping.
                       Added Keysyms will be removed periodically and also
                       when x11vnc exits.  Default: -add_keysyms
-clear_mods            At startup and exit clear the modifier keys by sending
                       KeyRelease for each one. The Lock modifiers are skipped.
                       Used to clear the state if the display was accidentally
                       left with any pressed down.
-clear_keys            As -clear_mods, except try to release any pressed key.
                       Note that this option and -clear_mods can interfere
                       with a person typing at the physical keyboard.
-remap string          Read Keysym remappings from file named "string".
                       Format is one pair of Keysyms per line (can be name
                       or hex value) separated by a space.  If no file named
                       "string" exists, it is instead interpreted as this
                       form: key1-key2,key3-key4,...  See <X11/keysymdef.h>
                       header file for a list of Keysym names, or use xev(1).
                       To map a key to a button click, use the fake Keysyms
                       "Button1", ..., etc. E.g: "-remap Super_R-Button2"
                       (useful for pasting on a laptop)

                       Dead keys: "dead" (or silent, mute) keys are keys that
                       do not produce a character but must be followed by a 2nd
                       keystroke.  This is often used for accenting characters,
                       e.g. to put "'" on top of "a" by pressing the dead
                       key and then "a".  Note that this interpretation
                       is not part of core X11, it is up to the toolkit or
                       application to decide how to react to the sequence.
                       The X11 names for these keysyms are "dead_grave",
                       "dead_acute", etc.  However some VNC viewers send the
                       keysyms "grave", "acute" instead thereby disabling
                       the accenting.  To work around this -remap can be used.
                       For example "-remap grave-dead_grave,acute-dead_acute"
                       As a convenience, "-remap DEAD" applies these remaps:

                               g     grave-dead_grave
                               a     acute-dead_acute
                               c     asciicircum-dead_circumflex
                               t     asciitilde-dead_tilde
                               m     macron-dead_macron
                               b     breve-dead_breve
                               D     abovedot-dead_abovedot
                               d     diaeresis-dead_diaeresis
                               o     degree-dead_abovering
                               A     doubleacute-dead_doubleacute
                               r     caron-dead_caron
                               e     cedilla-dead_cedilla

                       If you just want a subset use the first letter
                       label, e.g. "-remap DEAD=ga" to get the first two.
                       Additional remaps may also be supplied via commas,
                       e.g.  "-remap DEAD=ga,Super_R-Button2".  Finally,
                       "DEAD=missing" means to apply all of the above as
                       long as the left hand member is not already in the
                       X11 keymap.

-norepeat              Option -norepeat disables X server key auto repeat when
-repeat                VNC clients are connected and VNC keyboard input is
                       not idle for more than 5 minutes.  This works around a
                       repeating keystrokes bug (triggered by long processing
                       delays between key down and key up client events: either
                       from large screen changes or high latency).
                       Default: -norepeat

                       Note: your VNC viewer side will likely do autorepeating,
                       so this is no loss unless someone is simultaneously at
                       the real X display.

                       Use "-norepeat N" to set how many times norepeat will
                       be reset if something else (e.g. X session manager)
                       disables it.  The default is 2.  Use a negative value
                       for unlimited resets.

-nofb                  Ignore video framebuffer: only process keyboard and
                       pointer.  Intended for use with Win2VNC and x2vnc
                       dual-monitor setups.
-nobell                Do not watch for XBell events. (no beeps will be heard)
                       Note: XBell monitoring requires the XKEYBOARD extension.
-nosel                 Do not manage exchange of X selection/cutbuffer between
                       VNC viewers and the X server.
-noprimary             Do not poll the PRIMARY selection for changes to send
                       back to clients.  (PRIMARY is still set on received
                       changes, however).
-seldir string         If direction string is "send", only send the selection
                       to viewers, and if it is "recv" only receive it from
                       viewers.  To work around apps setting the selection
                       too frequently and messing up the other end.  You can
                       actually supply a comma separated list of directions,
                       including "debug" to turn on debugging output.

-cursor [mode]         Sets how the pointer cursor shape (little icon at the
-nocursor              mouse pointer) should be handled.  The "mode" string
                       is optional and is described below.  The default
                       is to show some sort of cursor shape(s).  How this
                       is done depends on the VNC viewer and the X server.
                       Use -nocursor to disable cursor shapes completely.

                       Some VNC viewers support the TightVNC CursorPosUpdates
                       and CursorShapeUpdates extensions (cuts down on
                       network traffic by not having to send the cursor image
                       every time the pointer is moved), in which case these
                       extensions are used (see -nocursorshape and -nocursorpos
                       below to disable).  For other viewers the cursor shape
                       is written directly to the framebuffer every time the
                       pointer is moved or changed and gets sent along with
                       the other framebuffer updates.  In this case, there
                       will be some lag between the vnc viewer pointer and
                       the remote cursor position.

                       If the X display supports retrieving the cursor shape
                       information from the X server, then the default is
                       to use that mode.  On Solaris this can be done with
                       the SUN_OVL extension using -overlay (see also the
                       -overlay_nomouse option).  A similar overlay scheme
                       is used on IRIX.  Xorg (e.g. Linux) and recent Solaris
                       Xsun servers support the XFIXES extension to retrieve
                       the exact cursor shape from the X server.  If XFIXES
                       is present it is preferred over Overlay and is used by
                       default (see -noxfixes below).  This can be disabled
                       with -nocursor, and also some values of the "mode"
                       option below.

                       Note that under XFIXES cursors with transparency (alpha
                       channel) will not be exactly represented and one may
                       find Overlay preferable.  See also the -alphacut and
                       -alphafrac options below as fudge factors to try to
                       improve the situation for cursors with transparency
                       for a given theme.

                       The "mode" string can be used to fine-tune the
                       displaying of cursor shapes.  It can be used the
                       following ways:

                       "-cursor arrow" - just show the standard arrow
                       nothing more or nothing less.

                       "-cursor none" - same as "-nocursor"

                       "-cursor X" - when the cursor appears to be on the
                       root window, draw the familiar X shape.  Some desktops
                       such as GNOME cover up the root window completely,
                       and so this will not work, try "X1", etc, to try to
                       shift the tree depth.  On high latency links or slow
                       machines there will be a time lag between expected and
                       the actual cursor shape.

                       "-cursor some" - like "X" but use additional
                       heuristics to try to guess if the window should have
                       a windowmanager-like resizer cursor or a text input
                       I-beam cursor.  This is a complete hack, but may be
                       useful in some situations because it provides a little
                       more feedback about the cursor shape.

                       "-cursor most" - try to show as many cursors as
                       possible.  Often this will only be the same as "some"
                       unless the display has overlay visuals or XFIXES
                       extensions available.  On Solaris and IRIX if XFIXES
                       is not available, -overlay mode will be attempted.

-arrow n               Choose an alternate "arrow" cursor from a set of
                       some common ones.  n can be 1 to 6.  Default is: 1

-noxfixes              Do not use the XFIXES extension to draw the exact cursor
                       shape even if it is available.
-alphacut n            When using the XFIXES extension for the cursor shape,
                       cursors with transparency will not be displayed exactly
                       (but opaque ones will).  This option sets n as a cutoff
                       for cursors that have transparency ("alpha channel"
                       with values ranging from 0 to 255) Any cursor pixel with
                       alpha value less than n becomes completely transparent.
                       Otherwise the pixel is completely opaque.  Default 240

                       Note: the options -alphacut, -alphafrac, and -alphafrac
                       may be removed if a more accurate internal method for
                       handling cursor transparency is implemented.
-alphafrac fraction    With the threshold in -alphacut some cursors will become
                       almost completely transparent because their alpha values
                       are not high enough.  For those cursors adjust the
                       alpha threshold until fraction of the non-zero alpha
                       channel pixels become opaque.  Default 0.33
-alpharemove           By default, XFIXES cursors pixels with transparency have
                       the alpha factor multiplied into the RGB color values
                       (i.e. that corresponding to blending the cursor with a
                       black background).  Specify this option to remove the
                       alpha factor. (useful for light colored semi-transparent
                       cursors).
-noalphablend          In XFIXES mode do not send cursor alpha channel data
                       to libvncserver.  The default is to send it.  The
                       alphablend effect will only be visible in -nocursorshape
                       mode or for clients with cursorshapeupdates turned
                       off. (However there is a hack for 32bpp with depth 24,
                       it uses the extra 8 bits to store cursor transparency
                       for use with a hacked vncviewer that applies the
                       transparency locally.  See the FAQ for more info).

-nocursorshape         Do not use the TightVNC CursorShapeUpdates extension
                       even if clients support it.  See -cursor above.
-cursorpos             Option -cursorpos enables sending the X cursor position
-nocursorpos           back to all vnc clients that support the TightVNC
                       CursorPosUpdates extension.  Other clients will be able
                       to see the pointer motions. Default: -cursorpos
-xwarppointer          Move the pointer with XWarpPointer(3X) instead of
                       the XTEST extension.  Use this as a workaround
                       if the pointer motion behaves incorrectly, e.g.
                       on touchscreens or other non-standard setups.
                       Also sometimes needed on XINERAMA displays.

-buttonmap string      String to remap mouse buttons.  Format: IJK-LMN, this
                       maps buttons I -> L, etc., e.g.  -buttonmap 13-31

                       Button presses can also be mapped to keystrokes: replace
                       a button digit on the right of the dash with :<sym>:
                       or :<sym1>+<sym2>: etc. for multiple keys. For example,
                       if the viewing machine has a mouse-wheel (buttons 4 5)
                       but the x11vnc side does not, these will do scrolls:
                              -buttonmap 12345-123:Prior::Next:
                              -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:

                       See <X11/keysymdef.h> header file for a list of Keysyms,
                       or use the xev(1) program.  Note: mapping of button
                       clicks to Keysyms may not work if -modtweak or -xkb is
                       needed for the Keysym.

                       If you include a modifier like "Shift_L" the
                       modifier's up/down state is toggled, e.g. to send
                       "The" use :Shift_L+t+Shift_L+h+e: (the 1st one is
                       shift down and the 2nd one is shift up). (note: the
                       initial state of the modifier is ignored and not reset)
                       To include button events use "Button1", ... etc.

-nodragging            Do not update the display during mouse dragging events
                       (mouse button held down).  Greatly improves response on
                       slow setups, but you lose all visual feedback for drags,
                       text selection, and some menu traversals.  It overrides
                       any -pointer_mode setting

-wireframe [str]       Try to detect window moves or resizes when a mouse
-nowireframe           button is held down and show a wireframe instead of
                       the full opaque window.  This is based completely on
                       heuristics and may not always work: it depends on your
                       window manager and even how you move things around.
                       See -pointer_mode below for discussion of the "bogging
                       down" problem this tries to avoid.
                       Default: -wireframe

                       Shorter aliases:  -wf [str]  and -nowf

                       The value "str" is optional and, of course, is
                       packed with many tunable parameters for this scheme:

                       Format: shade,linewidth,percent,T+B+L+R,mod,t1+t2+t3+t4
                       Default: 0xff,3,0,32+8+8+8,all,0.15+0.30+5.0+0.125

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "shade" indicate the "color" for the wireframe,
                       usually a greyscale: 0-255, however for 16 and 32bpp you
                       can specify an rgb.txt X color (e.g. "dodgerblue") or
                       a value > 255 is treated as RGB (e.g. red is 0xff0000).
                       "linewidth" sets the width of the wireframe in pixels.
                       "percent" indicates to not apply the wireframe scheme
                       to windows with area less than this percent of the
                       full screen.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider wireframing.
                       This is a speedup to quickly exclude a window from being
                       wireframed: set them all to zero to not try the speedup
                       (scrolling and selecting text will likely be slower).

                       "mod" specifies if a button down event in the
                       interior of the window with a modifier key (Alt, Shift,
                       etc.) down should indicate a wireframe opportunity.
                       It can be "0" or "none" to skip it, "1" or "all"
                       to apply it to any modifier, or "Shift", "Alt",
                       "Control", "Meta", "Super", or "Hyper" to only
                       apply for that type of modifier key.

                       "t1+t2+t3+t4" specify four floating point times in
                       seconds: t1 is how long to wait for the pointer to move,
                       t2 is how long to wait for the window to start moving
                       or being resized (for some window managers this can be
                       rather long), t3 is how long to keep a wireframe moving
                       before repainting the window. t4 is the minimum time
                       between sending wireframe "animations".  For a slow
                       link this might be a better choice: 0.25+0.6+6.0+0.15

-wirecopyrect mode     Since the -wireframe mechanism evidently tracks moving
-nowirecopyrect        windows accurately, a speedup can be obtained by
                       telling the VNC viewers to locally copy the translated
                       window region.  This is the VNC CopyRect encoding:
                       the framebuffer update doesn't need to send the actual
                       new image data.

                       Shorter aliases:  -wcr [mode]  and -nowcr

                       "mode" can be "never" (same as -nowirecopyrect)
                       to never try the copyrect, "top" means only do it if
                       the window was not covered by any other windows, and
                       "always" means to translate the orginally unobscured
                       region (this may look odd as the remaining pieces come
                       in, but helps on a slow link).  Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-wirecopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

-debug_wireframe       Turn on debugging info printout for the wireframe
                       heuristics.  "-dwf" is an alias.  Specify multiple
                       times for more output.

-scrollcopyrect mode   Like -wirecopyrect, but use heuristics to try to guess
-noscrollcopyrect      if a window has scrolled its contents (either vertically
                       or horizontally).  This requires the RECORD X extension
                       to "snoop" on X applications (currently for certain
                       XCopyArea and XConfigureWindow X protocol requests).
                       Examples: Hitting <Return> in a terminal window when the
                       cursor was at the bottom, the text scrolls up one line.
                       Hitting <Down> arrow in a web browser window, the web
                       page scrolls up a small amount.  Or scrolling with a
                       scrollbar or mouse wheel.

                       Shorter aliases:  -scr [mode]  and -noscr

                       This scheme will not always detect scrolls, but when
                       it does there is a nice speedup from using the VNC
                       CopyRect encoding (see -wirecopyrect).  The speedup
                       is both in reduced network traffic and reduced X
                       framebuffer polling/copying.  On the other hand, it may
                       induce undesired transients (e.g. a terminal cursor
                       being scrolled up when it should not be) or other
                       painting errors (window tearing, bunching-up, etc).
                       These are automatically repaired in a short period
                       of time.  If this is unacceptable disable the feature
                       with -noscrollcopyrect.

                       Screen clearing kludges:  for testing at least, there
                       are some "magic key sequences" (must be done in less
                       than 1 second) to aid repairing painting errors that
                       may be seen when using this mode:

                       3 Alt_L's   in a row: resend whole screen,
                       4 Alt_L's   in a row: reread and resend whole screen,
                       3 Super_L's in a row: mark whole screen for polling,
                       4 Super_L's in a row: reset RECORD context,
                       5 Super_L's in a row: try to push a black screen

                       note: Alt_L is the Left "Alt" key (a single key)
                       Super_L is the Left "Super" key (Windows flag).
                       Both of these are modifier keys, and so should not
                       generate characters when pressed by themselves.  Also,
                       your VNC viewer may have its own refresh hot-key
                       or button.

                       "mode" can be "never" (same as -noscrollcopyrect)
                       to never try the copyrect, "keys" means to try it
                       in response to keystrokes only, "mouse" means to
                       try it in response to mouse events only, "always"
                       means to do both. Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-scrollcopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

-scr_area n            Set the minimum area in pixels for a rectangle
                       to be considered for the -scrollcopyrect detection
                       scheme.  This is to avoid wasting the effort on small
                       rectangles that would be quickly updated the normal way.
                       E.g. suppose an app updated the position of its skinny
                       scrollbar first and then shifted the large panel
                       it controlled.  We want to be sure to skip the small
                       scrollbar and get the large panel. Default: 60000

-scr_skip list         Skip scroll detection for applications matching
                       the comma separated list of strings in "list".
                       Some applications implement their scrolling in
                       strange ways where the XCopyArea, etc, also applies
                       to invisible portions of the window: if we CopyRect
                       those areas it looks awful during the scroll and
                       there may be painting errors left after the scroll.
                       Soffice.bin is the worst known offender.

                       Use "##" to denote the start of the application class
                       (e.g. "##XTerm") and "++" to denote the start
                       of the application instance name (e.g. "++xterm").
                       The string your list is matched against is of the form
                       "^^WM_NAME##Class++Instance<same-for-any-subwindows>"
                       The "xlsclients -la" command will provide this info.

                       If a pattern is prefixed with "KEY:" it only applies
                       to Keystroke generated scrolls (e.g. Up arrow).  If it
                       is prefixed with "MOUSE:" it only applies to Mouse
                       induced scrolls (e.g. dragging on a scrollbar).
                       Default: ##Soffice.bin,##StarOffice

-scr_inc list          Opposite of -scr_skip: this list is consulted first
                       and if there is a match the window will be monitored
                       via RECORD for scrolls irrespective of -scr_skip.
                       Use -scr_skip '*' to skip anything that does not match
                       your -scr_inc.  Use -scr_inc '*' to include everything.

-scr_keys list         For keystroke scroll detection, only apply the RECORD
                       heuristics to the comma separated list of keysyms in
                       "list".  You may find the RECORD overhead for every
                       one of your keystrokes disrupts typing too much, but you
                       don't want to turn it off completely with "-scr mouse"
                       and -scr_parms does not work or is too confusing.

                       The listed keysyms can be numeric or the keysym
                       names in the <X11/keysymdef.h> header file or from the
                       xev(1) program.  Example: "-scr_keys Up,Down,Return".
                       One probably wants to have application specific lists
                       (e.g. for terminals, etc) but that is too icky to think
                       about for now...

                       If "list" begins with the "-" character the list
                       is taken as an exclude list: all keysyms except those
                       list will be considered.  The special string "builtin"
                       expands to an internal list of keysyms that are likely
                       to cause scrolls.  BTW, by default modifier keys,
                       Shift_L, Control_R, etc, are skipped since they almost
                       never induce scrolling by themselves.

-scr_term list         Yet another cosmetic kludge.  Apply shell/terminal
                       heuristics to applications matching comma separated
                       list (same as for -scr_skip/-scr_inc).  For example an
                       annoying transient under scroll detection is if you
                       hit Enter in a terminal shell with full text window,
                       the solid text cursor block will be scrolled up.
                       So for a short time there are two (or more) block
                       cursors on the screen.  There are similar scenarios,
                       (e.g. an output line is duplicated).

                       These transients are induced by the approximation of
                       scroll detection (e.g. it detects the scroll, but not
                       the fact that the block cursor was cleared just before
                       the scroll).  In nearly all cases these transient errors
                       are repaired when the true X framebuffer is consulted
                       by the normal polling.  But they are distracting, so
                       what this option provides is extra "padding" near the
                       bottom of the terminal window: a few extra lines near
                       the bottom will not be scrolled, but rather updated
                       from the actual X framebuffer.  This usually reduces
                       the annoying artifacts.  Use "none" to disable.
                       Default: "term"

-scr_keyrepeat lo-hi   If a key is held down (or otherwise repeats rapidly) and
                       this induces a rapid sequence of scrolls (e.g. holding
                       down an Arrow key) the "scrollcopyrect" detection
                       and overhead may not be able to keep up.  A time per
                       single scroll estimate is performed and if that estimate
                       predicts a sustainable scrollrate of keys per second
                       between "lo" and "hi" then repeated keys will be
                       DISCARDED to maintain the scrollrate. For example your
                       key autorepeat may be 25 keys/sec, but for a large
                       window or slow link only 8 scrolls per second can be
                       sustained, then roughly 2 out of every 3 repeated keys
                       will be discarded during this period. Default: "4-20"

-scr_parms string      Set various parameters for the scrollcopyrect mode.
                       The format is similar to that for -wireframe and packed
                       with lots of parameters:

                       Format: T+B+L+R,t1+t2+t3,s1+s2+s3+s4+s5
                       Default: 0+64+32+32,0.02+0.10+0.9,0.03+0.06+0.5+0.1+5.0

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider scrollcopyrect.
                       If -wireframe overlaps it takes precedence.  This is a
                       speedup to quickly exclude a window from being watched
                       for scrollcopyrect: set them all to zero to not try
                       the speedup (things like selecting text will likely
                       be slower).

                       "t1+t2+t3" specify three floating point times in
                       seconds that apply to scrollcopyrect detection with
                       *Keystroke* input: t1 is how long to wait after a key
                       is pressed for the first scroll, t2 is how long to keep
                       looking after a Keystroke scroll for more scrolls.
                       t3 is how frequently to try to update surrounding
                       scrollbars outside of the scrolling area (0.0 to
                       disable)

                       "s1+s2+s3+s4+s5" specify five floating point times
                       in seconds that apply to scrollcopyrect detection with
                       *Mouse* input: s1 is how long to wait after a mouse
                       button is pressed for the first scroll, s2 is how long
                       to keep waiting for additional scrolls after the first
                       Mouse scroll was detected.  s3 is how frequently to
                       try to update surrounding scrollbars outside of the
                       scrolling area (0.0 to disable).  s4 is how long to
                       buffer pointer motion (to try to get fewer, bigger
                       mouse scrolls). s5 is the maximum time to spend just
                       updating the scroll window without updating the rest
                       of the screen.

-fixscreen string      Periodically "repair" the screen based on settings
                       in "string".  Hopefully you won't need this option,
                       it is intended for cases when the -scrollcopyrect or
                       -wirecopyrect features leave too many painting errors,
                       but it can be used for any scenario.  This option
                       periodically performs costly operations and so
                       interactive response may be reduced when it is on.
                       The 3 Alt_L's (the Left "Alt" key) taps in a row
                       described under -scrollcopyrect can be used instead to
                       manually request a screen repaint when it is needed.

                       "string" is a comma separated list of one or more of
                       the following: "V=t", "C=t", and "X=t".  In these
                       "t" stands for a time in seconds (it is a floating
                       point even though one should usually use values > 2 to
                       avoid wasting resources).  V sets how frequently the
                       entire screen should be sent to viewers (it is like the
                       3 Alt_L's).  C sets how long to wait after a CopyRect
                       to repaint the full screen.  X sets how frequently
                       to reread the full X11 framebuffer from the X server
                       and push it out to connected viewers.  Use of X should
                       be rare, please report a bug if you find you need it.
                       Examples: -fixscreen V=10 -fixscreen C=10

-debug_scroll          Turn on debugging info printout for the scroll
                       heuristics.  "-ds" is an alias.  Specify it multiple
                       times for more output.

-noxrecord             Disable any use of the RECORD extension.  This is
                       currently used by the -scrollcopyrect scheme and to
                       monitor X server grabs.

-pointer_mode n        Various pointer motion update schemes. "-pm" is
                       an alias.  The problem is pointer motion can cause
                       rapid changes on the screen: consider the rapid changes
                       when you drag a large window around.  Neither x11vnc's
                       screen polling and vnc compression routines nor the
                       bandwidth to the vncviewers can keep up these rapid
                       screen changes: everything will bog down when dragging
                       or scrolling.  So a scheme has to be used to "eat"
                       much of that pointer input before re-polling the screen
                       and sending out framebuffer updates. The mode number
                       "n" can be 0 to 4 and selects one of the schemes
                       desribed below.

                       n=0: does the same as -nodragging. (all screen polling
                       is suspended if a mouse button is pressed.)

                       n=1: was the original scheme used to about Jan 2004:
                       it basically just skips -input_skip keyboard or pointer
                       events before repolling the screen.

                       n=2 is an improved scheme: by watching the current rate
                       of input events it tries to detect if it should try to
                       "eat" additional pointer events before continuing.

                       n=3 is basically a dynamic -nodragging mode: it detects
                       when the mouse motion has paused and then refreshes
                       the display.

                       n=4 attempts to measures network rates and latency,
                       the video card read rate, and how many tiles have been
                       changed on the screen.  From this, it aggressively tries
                       to push screen "frames" when it decides it has enough
                       resources to do so.  NOT FINISHED.

                       The default n is 2. Note that modes 2, 3, 4 will skip
                       -input_skip keyboard events (but it will not count
                       pointer events).  Also note that these modes are not
                       available in -threads mode which has its own pointer
                       event handling mechanism.

                       To try out the different pointer modes to see which
                       one gives the best response for your usage, it is
                       convenient to use the remote control function, for
                       example "x11vnc -R pm:4" or the tcl/tk gui (Tuning ->
                       pointer_mode -> n).

-input_skip n          For the pointer handling when non-threaded: try to
                       read n user input events before scanning display. n < 0
                       means to act as though there is always user input.
                       Default: 10

-speeds rd,bw,lat      x11vnc tries to estimate some speed parameters that
                       are used to optimize scheduling (e.g. -pointer_mode
                       4) and other things.  Use the -speeds option to set
                       these manually.  The triple "rd,bw,lat" corresponds
                       to video h/w read rate in MB/sec, network bandwidth to
                       clients in KB/sec, and network latency to clients in
                       milliseconds, respectively.  If a value is left blank,
                       e.g. "-speeds ,100,15", then the internal scheme is
                       used to estimate the empty value(s).

                       Note: use this option is currently NOT FINISHED.

                       Typical PC video cards have read rates of 5-10 MB/sec.
                       If the framebuffer is in main memory instead of video
                       h/w (e.g. SunRay, shadowfb, Xvfb), the read rate may
                       be much faster.  "x11perf -getimage500" can be used
                       to get a lower bound (remember to factor in the bytes
                       per pixel).  It is up to you to estimate the network
                       bandwith and latency to clients.  For the latency the
                       ping(1) command can be used.

                       For convenience there are some aliases provided,
                       e.g. "-speeds modem".  The aliases are: "modem" for
                       6,4,200; "dsl" for 6,100,50; and "lan" for 6,5000,1

-debug_pointer         Print debugging output for every pointer event.
-debug_keyboard        Print debugging output for every keyboard event.
                       Same as -dp and -dk, respectively.  Use multiple
                       times for more output.

-defer time            Time in ms to wait for updates before sending to client
                       (deferUpdateTime)  Default: 30
-wait time             Time in ms to pause between screen polls.  Used to cut
                       down on load.  Default: 30
-wait_ui factor        Factor by which to cut the -wait time if there
                       has been recent user input (pointer or keyboard).
                       Improves response, but increases the load whenever you
                       are moving the mouse or typing.  Default: 2.00
-nowait_bog            Do not detect if the screen polling is "bogging down"
                       and sleep more.  Some activities with no user input can
                       slow things down a lot: consider a large terminal window
                       with a long build running in it continously streaming
                       text output.  By default x11vnc will try to detect this
                       (3 screen polls in a row each longer than 0.25 sec with
                       no user input), and sleep up to 1.5 secs to let things
                       "catch up".  Use this option to disable the detection.
-readtimeout n         Set libvncserver rfbMaxClientWait to n seconds. On
                       slow links that take a long time to paint the first
                       screen libvncserver may hit the timeout and drop the
                       connection.  Default: 20 seconds.
-nap                   Monitor activity and if it is low take longer naps
-nonap                 between screen polls to really cut down load when idle.
                       Default: take naps
-sb time               Time in seconds after NO activity (e.g. screen blank)
                       to really throttle down the screen polls (i.e. sleep
                       for about 1.5 secs). Use 0 to disable.  Default: 60

-noxdamage             Do not use the X DAMAGE extension to detect framebuffer
                       changes even if it is available.  Use -xdamage if your
                       default is to have it off.

                       x11vnc's use of the DAMAGE extension: 1) significantly
                       reduces the load when the screen is not changing much,
                       and 2) detects changed areas (small ones by default)
                       more quickly.

                       Currently the DAMAGE extension is overly conservative
                       and often reports large areas (e.g. a whole terminal
                       or browser window) as damaged even though the actual
                       changed region is much smaller (sometimes just a few
                       pixels).  So heuristics were introduced to skip large
                       areas and use the damage rectangles only as "hints"
                       for the traditional scanline polling.  The following
                       tuning parameters are introduced to adjust this
                       behavior:

-xd_area A             Set the largest DAMAGE rectangle area "A" (in
                       pixels: width * height) to trust as truly damaged:
                       the rectangle will be copied from the framebuffer
                       (slow) no matter what.  Set to zero to trust *all*
                       rectangles. Default: 20000
-xd_mem f              Set how long DAMAGE rectangles should be "remembered",
                       "f" is a floating point number and is in units of the
                       scanline repeat cycle time (32 iterations).  The default
                       (1.0) should give no painting problems. Increase it if
                       there are problems or decrease it to live on the edge
                       (perhaps useful on a slow machine).

-sigpipe string        Broken pipe (SIGPIPE) handling.  "string" can be
                       "ignore" or "exit".  For "ignore" libvncserver
                       will handle the abrupt loss of a client and continue,
                       for "exit" x11vnc will cleanup and exit at the 1st
                       broken connection.  Default: "ignore".
-threads               Whether or not to use the threaded libvncserver
-nothreads             algorithm [rfbRunEventLoop] if libpthread is available
                       Default: -nothreads

-fs f                  If the fraction of changed tiles in a poll is greater
                       than f, the whole screen is updated.  Default: 0.75
-gaps n                Heuristic to fill in gaps in rows or cols of n or
                       less tiles.  Used to improve text paging.  Default: 4
-grow n                Heuristic to grow islands of changed tiles n or wider
                       by checking the tile near the boundary.  Default: 3
-fuzz n                Tolerance in pixels to mark a tiles edges as changed.
                       Default: 2
-debug_tiles           Print debugging output for tiles, fb updates, etc.

-snapfb                Instead of polling the X display framebuffer (fb) for
                       changes, periodically copy all of X display fb into main
                       memory and examine that copy for changes.  Under some
                       circumstances this will improve interactive response,
                       or at least make things look smoother, but in others
                       (many) it will make the response worse.  If the video
                       h/w fb is such that reading small tiles is very slow
                       this mode could help.  To keep the "framerate" up
                       the screen size x bpp cannot be too large.  Note that
                       this mode is very wasteful of memory I/O resources
                       (it makes full screen copies even if nothing changes).
                       It may be of use in video capture-like applications,
                       or where window tearing is a problem.

-rawfb string          Experimental option, instead of polling X, poll the
                       memory object specified in "string".  For shared
                       memory segments it is of the form: "shm:N@WxHxB"
                       which specifies a shmid N and framebuffer Width, Height,
                       and Bits per pixel.  To memory map mmap(2) a file use:
                       "map:/path/to/a/file@WxHxB".  If there is trouble
                       with mmap, use  "file:/..." for slower lseek(2)
                       based reading.  If you do not supply a type "map"
                       is assumed if the file exists.

                       If string is "setup:cmd", then the command "cmd"
                       is run and the first line from it is read and used
                       as "string".  This allows initializing the device,
                       determining WxHxB, etc. These are often done as root
                       so take care.

                       Optional suffixes are ":R/G/B" and "+O" to specify
                       red, green, and blue masks and an offset into the
                       memory object.  If the masks are not provided x11vnc
                       guesses them based on the bpp.

                       Examples:
                           -rawfb shm:210337933@800x600x32:ff/ff00/ff0000
                           -rawfb map:/dev/fb0@1024x768x32
                           -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232
                           -rawfb file:/tmp/my.pnm@250x200x24+37

                       (see ipcs(1) and fbset(1) for the first two examples)

                       All user input is discarded.  Most of the X11 (screen,
                       keyboard, mouse) options do not make sense and many
                       will cause this mode to crash, so please think twice
                       before setting/changing them.

                       If you don't want x11vnc to close the X DISPLAY in
                       rawfb mode, then capitalize the prefix, SHM:, MAP:,
                       FILE:   Keeping the display open enables the default
                       remote-control channel, which could be useful.  Also,
                       if you also specify -noviewonly, then the mouse and
                       keyboard input are still sent to the X display, this
                       usage should be very rare, i.e. doing something strange
                       with /dev/fb0.

-pipeinput cmd         Another experimental option: it lets you supply an
                       external command in "cmd" that x11vnc will pipe
                       all of the user input events to in a simple format.
                       In -pipeinput mode by default x11vnc will not process
                       any of the user input events.  If you prefix "cmd"
                       with "tee:" it will both send them to the pipe
                       command and process them.  For a description of the
                       format run "-pipeinput tee:/bin/cat".  Another prefix
                       is "reopen" which means to reopen pipe if it exits.
                       Separate multiple prefixes with commas.

                       In combination with -rawfb one might be able to
                       do amusing things (e.g. control non-X devices).
                       To facilitate this, if -rawfb is in effect then the
                       value is stored in X11VNC_RAWFB_STR for the pipe command
                       to use if it wants. Do 'env | grep X11VNC' for more.

-gui [gui-opts]        Start up a simple tcl/tk gui based on the the remote
                       control options -remote/-query described below.
                       Requires the "wish" program to be installed on the
                       machine.  "gui-opts" is not required: the default is
                       to start up both the gui and x11vnc with the gui showing
                       up on the X display in the environment variable DISPLAY.

                       "gui-opts" can be a comma separated list of items.
                       Currently there are these types of items: 1) a gui mode,
                       a 2) gui "simplicity", and 3) the X display the gui
                       should display on.

                       1) The gui mode can be "start", "conn", or "wait"
                       "start" is the default mode above and is not required.
                       "conn" means do not automatically start up x11vnc,
                       but instead just try to connect to an existing x11vnc
                       process.  "wait" means just start the gui and nothing
                       else (you will later instruct the gui to start x11vnc
                       or connect to an existing one.)

                       2) The gui simplicity is off by default (a power-user
                       gui with all options is presented) To start with
                       something less daunting supply the string "simple"
                       ("ez" is an alias for this).  Once the gui is
                       started you can toggle between the two with "Misc ->
                       simple_gui".

                       3) Note the possible confusion regarding the potentially
                       two different X displays: x11vnc polls one, but you
                       may want the gui to appear on another.  For example, if
                       you ssh in and x11vnc is not running yet you may want
                       the gui to come back to you via your ssh redirected X
                       display (e.g. localhost:10).

                       Examples: "x11vnc -gui", "x11vnc -gui ez"
                       "x11vnc -gui localhost:10", "x11vnc -gui conn,host:0"

                       If you do not specify a gui X display in "gui-opts"
                       then the DISPLAY environment variable and -display
                       option are tried (in that order).  Regarding the x11vnc
                       X display the gui will try to connect to, it first
                       tries -display and then DISPLAY.  For example, "x11vnc
                       -display :0 -gui otherhost:0", will remote control an
                       x11vnc polling :0 and display the gui on otherhost:0

                       If you do not intend to start x11vnc from the gui
                       (i.e. just remote control an existing one), then the
                       gui process can run on a different machine from the
                       x11vnc server as long as X permissions, etc. permit
                       communication between the two.

-remote command        Remotely control some aspects of an already running
                       x11vnc server.  "-R" and "-r" are aliases for
                       "-remote".  After the remote control command is
                       sent to the running server the 'x11vnc -remote ...'
                       command exits.  You can often use the -query command
                       (see below) to see if the x11vnc server processed your
                       -remote command.

                       The default communication channel is that of X
                       properties (specifically VNC_CONNECT), and so this
                       command must be run with correct settings for DISPLAY
                       and possibly XAUTHORITY to connect to the X server
                       and set the property.  Alternatively, use the -display
                       and -auth options to set them to the correct values.
                       The running server cannot use the -novncconnect option
                       because that disables the communication channel.
                       See below for alternate channels.

                       For example: 'x11vnc -remote stop' (which is the same as
                       'x11vnc -R stop') will close down the x11vnc server.
                       'x11vnc -R shared' will enable shared connections, and
                       'x11vnc -R scale:3/4' will rescale the desktop.

                       Note: the more drastic the change induced by the -remote
                       command, the bigger the chance for bugs or crashes.
                       Please report reproducible bugs.

                       The following -remote/-R commands are supported:

                       stop            terminate the server, same as "quit"
                                       "exit" or "shutdown".
                       ping            see if the x11vnc server responds.
                                       Return is: ans=ping:<xdisplay>
                       blacken         try to push a black fb update to all
                                       clients (due to timings a client
                                       could miss it). Same as "zero", also
                                       "zero:x1,y1,x2,y2" for a rectangle.
                       refresh         send the entire fb to all clients.
                       reset           recreate the fb, polling memory, etc.
                       id:windowid     set -id window to "windowid". empty
                                       or "root" to go back to root window
                       sid:windowid    set -sid window to "windowid"
                       waitmapped      wait until subwin is mapped.
                       nowaitmapped    do not wait until subwin is mapped.
                       clip:WxH+X+Y    set -clip mode to "WxH+X+Y"
                       flashcmap       enable  -flashcmap mode.
                       noflashcmap     disable -flashcmap mode.
                       shiftcmap:n     set -shiftcmap to n.
                       notruecolor     enable  -notruecolor mode.
                       truecolor       disable -notruecolor mode.
                       overlay         enable  -overlay mode (if applicable).
                       nooverlay       disable -overlay mode.
                       overlay_cursor  in -overlay mode, enable cursor drawing.
                       overlay_nocursor disable cursor drawing. same as
                                        nooverlay_cursor.
                       visual:vis      set -visual to "vis"
                       scale:frac      set -scale to "frac"
                       scale_cursor:f  set -scale_cursor to "f"
                       viewonly        enable  -viewonly mode.
                       noviewonly      disable -viewonly mode.
                       shared          enable  -shared mode.
                       noshared        disable -shared mode.
                       forever         enable  -forever mode.
                       noforever       disable -forever mode.
                       timeout:n       reset -timeout to n, if there are
                                       currently no clients, exit unless one
                                       connects in the next n secs.
                       http            enable  http client connections.
                       nohttp          disable http client connections.
                       deny            deny any new connections, same as "lock"
                       nodeny          allow new connections, same as "unlock"
                       connect:host    do reverse connection to host, "host"
                                       may be a comma separated list of hosts
                                       or host:ports.  See -connect.
                       disconnect:host disconnect any clients from "host"
                                       same as "close:host".  Use host
                                       "all" to close all current clients.
                                       If you know the client internal hex ID,
                                       e.g. 0x3 (returned by "-query clients"
                                       and RFB_CLIENT_ID) you can use that too.
                       allowonce:host  For the next connection only, allow
                                       connection from "host".
                       allow:hostlist  set -allow list to (comma separated)
                                       "hostlist". See -allow and -localhost.
                                       Do not use with -allow /path/to/file
                                       Use "+host" to add a single host, and
                                       use "-host" to delete a single host
                       localhost       enable  -localhost mode
                       nolocalhost     disable -localhost mode
                       listen:str      set -listen to str, empty to disable.
                       nolookup        enable  -nolookup mode.
                       lookup          disable -nolookup mode.
                       input:str       set -input to "str", empty to disable.
                       client_input:str set the K, M, B -input on a per-client
                                       basis.  select which client as for
                                       disconnect, e.g. client_input:host:MB
                                       or client_input:0x2:K
                       accept:cmd      set -accept "cmd" (empty to disable).
                       gone:cmd        set -gone "cmd" (empty to disable).
                       noshm           enable  -noshm mode.
                       shm             disable -noshm mode (i.e. use shm).
                       flipbyteorder   enable -flipbyteorder mode, you may need
                                       to set noshm for this to do something.
                       noflipbyteorder disable -flipbyteorder mode.
                       onetile         enable  -onetile mode. (you may need to
                                       set shm for this to do something)
                       noonetile       disable -onetile mode.
                       solid           enable  -solid mode
                       nosolid         disable -solid mode.
                       solid_color:color set -solid color (and apply it).
                       blackout:str    set -blackout "str" (empty to disable).
                                       See -blackout for the form of "str"
                                       (basically: WxH+X+Y,...)
                                       Use "+WxH+X+Y" to append a single
                                       rectangle use "-WxH+X+Y" to delete one
                       xinerama        enable  -xinerama mode. (if applicable)
                       noxinerama      disable -xinerama mode.
                       xtrap           enable  -xtrap input mode.
                       noxtrap         disable -xtrap input mode.
                       xrandr          enable  -xrandr mode. (if applicable)
                       noxrandr        disable -xrandr mode.
                       xrandr_mode:mode set the -xrandr mode to "mode".
                       padgeom:WxH     set -padgeom to WxH (empty to disable)
                                       If WxH is "force" or "do" the padded
                                       geometry fb is immediately applied.
                       quiet           enable  -quiet mode.
                       noquiet         disable -quiet mode.
                       modtweak        enable  -modtweak mode.
                       nomodtweak      enable  -nomodtweak mode.
                       xkb             enable  -xkb modtweak mode.
                       noxkb           disable -xkb modtweak mode.
                       skip_keycodes:str enable -xkb -skip_keycodes "str".
                       skip_dups       enable  -skip_dups mode.
                       noskip_dups     disable -skip_dups mode.
                       add_keysyms     enable -add_keysyms mode.
                       noadd_keysyms   stop adding keysyms. those added will
                                       still be removed at exit.
                       clear_mods      enable  -clear_mods mode and clear them.
                       noclear_mods    disable -clear_mods mode.
                       clear_keys      enable  -clear_keys mode and clear them.
                       noclear_keys    disable -clear_keys mode.
                       remap:str       set -remap "str" (empty to disable).
                                       See -remap for the form of "str"
                                       (basically: key1-key2,key3-key4,...)
                                       Use "+key1-key2" to append a single
                                       keymapping, use "-key1-key2" to delete.
                       norepeat        enable  -norepeat mode.
                       repeat          disable -norepeat mode.
                       nofb            enable  -nofb mode.
                       fb              disable -nofb mode.
                       bell            enable  bell (if supported).
                       nobell          disable bell.
                       nosel           enable  -nosel mode.
                       sel             disable -nosel mode.
                       noprimary       enable  -noprimary mode.
                       primary         disable -noprimary mode.
                       seldir:str      set -seldir to "str"
                       cursor:mode     enable  -cursor "mode".
                       show_cursor     enable  showing a cursor.
                       noshow_cursor   disable showing a cursor. (same as
                                       "nocursor")
                       arrow:n         set -arrow to alternate n.
                       xfixes          enable  xfixes cursor shape mode.
                       noxfixes        disable xfixes cursor shape mode.
                       alphacut:n      set -alphacut to n.
                       alphafrac:f     set -alphafrac to f.
                       alpharemove     enable  -alpharemove mode.
                       noalpharemove   disable -alpharemove mode.
                       alphablend      disable -noalphablend mode.
                       noalphablend    enable  -noalphablend mode.
                       cursorshape     disable -nocursorshape mode.
                       nocursorshape   enable  -nocursorshape mode.
                       cursorpos       disable -nocursorpos mode.
                       nocursorpos     enable  -nocursorpos mode.
                       xwarp           enable  -xwarppointer mode.
                       noxwarp         disable -xwarppointer mode.
                       buttonmap:str   set -buttonmap "str", empty to disable
                       dragging        disable -nodragging mode.
                       nodragging      enable  -nodragging mode.
                       wireframe       enable  -wireframe mode. same as "wf"
                       nowireframe     disable -wireframe mode. same as "nowf"
                       wireframe:str   enable  -wireframe mode string.
                       wireframe_mode:str enable  -wireframe mode string.
                       wirecopyrect:str set -wirecopyrect string. same as "wcr:
"
                       scrollcopyrect:str set -scrollcopyrect string. same "scr
"
                       noscrollcopyrect disable -scrollcopyrect mode. "noscr"
                       scr_area:n      set -scr_area to n
                       scr_skip:list   set -scr_skip to "list"
                       scr_inc:list    set -scr_inc to "list"
                       scr_keys:list   set -scr_keys to "list"
                       scr_term:list   set -scr_term to "list"
                       scr_keyrepeat:str set -scr_keyrepeat to "str"
                       scr_parms:str   set -scr_parms parameters.
                       fixscreen:str   set -fixscreen to "str".
                       noxrecord       disable all use of RECORD extension.
                       xrecord         enable  use of RECORD extension.
                       reset_record    reset RECORD extension (if avail.).
                       pointer_mode:n  set -pointer_mode to n. same as "pm"
                       input_skip:n    set -input_skip to n.
                       speeds:str      set -speeds to str.
                       debug_pointer   enable  -debug_pointer, same as "dp"
                       nodebug_pointer disable -debug_pointer, same as "nodp"
                       debug_keyboard   enable  -debug_keyboard, same as "dk"
                       nodebug_keyboard disable -debug_keyboard, same as "nodk"
                       defer:n         set -defer to n ms,same as deferupdate:n
                       wait:n          set -wait to n ms.
                       wait_ui:f       set -wait_ui factor to f.
                       wait_bog        disable -nowait_bog mode.
                       nowait_bog      enable  -nowait_bog mode.
                       readtimeout:n   set read timeout to n seconds.
                       nap             enable  -nap mode.
                       nonap           disable -nap mode.
                       sb:n            set -sb to n s, same as screen_blank:n
                       xdamage         enable  xdamage polling hints.
                       noxdamage       disable xdamage polling hints.
                       xd_area:A       set -xd_area max pixel area to "A"
                       xd_mem:f        set -xd_mem remembrance to "f"
                       fs:frac         set -fs fraction to "frac", e.g. 0.5
                       gaps:n          set -gaps to n.
                       grow:n          set -grow to n.
                       fuzz:n          set -fuzz to n.
                       snapfb          enable  -snapfb mode.
                       nosnapfb        disable -snapfb mode.
                       rawfb:str       set -rawfb mode to "str".
                       progressive:n   set libvncserver -progressive slice
                                       height parameter to n.
                       desktop:str     set -desktop name to str for new clients
.
                       rfbport:n       set -rfbport to n.
                       httpport:n      set -httpport to n.
                       httpdir:dir     set -httpdir to dir (and enable http).
                       enablehttpproxy   enable  -enablehttpproxy mode.
                       noenablehttpproxy disable -enablehttpproxy mode.
                       alwaysshared     enable  -alwaysshared mode.
                       noalwaysshared   disable -alwaysshared mode.
                                        (may interfere with other options)
                       nevershared      enable  -nevershared mode.
                       nonevershared    disable -nevershared mode.
                                        (may interfere with other options)
                       dontdisconnect   enable  -dontdisconnect mode.
                       nodontdisconnect disable -dontdisconnect mode.
                                        (may interfere with other options)
                       debug_xevents   enable  debugging X events.
                       nodebug_xevents disable debugging X events.
                       debug_xdamage   enable  debugging X DAMAGE mechanism.
                       nodebug_xdamage disable debugging X DAMAGE mechanism.
                       debug_wireframe enable   debugging wireframe mechanism.
                       nodebug_wireframe disable debugging wireframe mechanism.
                       debug_scroll    enable  debugging scrollcopy mechanism.
                       nodebug_scroll  disable debugging scrollcopy mechanism.
                       debug_tiles     enable  -debug_tiles
                       nodebug_tiles   disable -debug_tiles
                       dbg             enable  -dbg crash shell
                       nodbg           disable -dbg crash shell

                       noremote        disable the -remote command processing,
                                       it cannot be turned back on.

                       The vncconnect(1) command from standard VNC
                       distributions may also be used if string is prefixed
                       with "cmd=" E.g. 'vncconnect cmd=stop'.  Under some
                       circumstances xprop(1) can used if it supports -set
                       (see the FAQ).

                       If "-connect /path/to/file" has been supplied to the
                       running x11vnc server then that file can be used as a
                       communication channel (this is the only way to remote
                       control one of many x11vnc's polling the same X display)
                       Simply run: 'x11vnc -connect /path/to/file -remote ...'
                       or you can directly write to the file via something
                       like: "echo cmd=stop > /path/to/file", etc.

-query variable        Like -remote, except just query the value of
                       "variable".  "-Q" is an alias for "-query".
                       Multiple queries can be done by separating variables
                       by commas, e.g. -query var1,var2. The results come
                       back in the form ans=var1:value1,ans=var2:value2,...
                       to the standard output.  If a variable is read-only,
                       it comes back with prefix "aro=" instead of "ans=".

                       Some -remote commands are pure actions that do not make
                       sense as variables, e.g. "stop" or "disconnect",
                       in these cases the value returned is "N/A".  To direct
                       a query straight to the VNC_CONNECT property or connect
                       file use "qry=..." instead of "cmd=..."

                       ans= stop quit exit shutdown ping blacken zero
                       refresh reset close disconnect id sid waitmapped
                       nowaitmapped clip flashcmap noflashcmap shiftcmap
                       truecolor notruecolor overlay nooverlay overlay_cursor
                       overlay_yescursor nooverlay_nocursor nooverlay_cursor
                       nooverlay_yescursor overlay_nocursor visual scale
                       scale_cursor viewonly noviewonly shared noshared
                       forever noforever once timeout deny lock nodeny unlock
                       connect allowonce allow localhost nolocalhost listen
                       lookup nolookup accept gone shm noshm flipbyteorder
                       noflipbyteorder onetile noonetile solid_color solid
                       nosolid blackout xinerama noxinerama xtrap noxtrap
                       xrandr noxrandr xrandr_mode padgeom quiet q noquiet
                       modtweak nomodtweak xkb noxkb skip_keycodes skip_dups
                       noskip_dups add_keysyms noadd_keysyms clear_mods
                       noclear_mods clear_keys noclear_keys remap repeat
                       norepeat fb nofb bell nobell sel nosel primary
                       noprimary seldir cursorshape nocursorshape cursorpos
                       nocursorpos cursor show_cursor noshow_cursor nocursor
                       arrow xfixes noxfixes xdamage noxdamage xd_area xd_mem
                       alphacut alphafrac alpharemove noalpharemove alphablend
                       noalphablend xwarppointer xwarp noxwarppointer noxwarp
                       buttonmap dragging nodragging wireframe_mode wireframe
                       wf nowireframe nowf wirecopyrect wcr nowirecopyrect
                       nowcr scr_area scr_skip scr_inc scr_keys scr_term
                       scr_keyrepeat scr_parms scrollcopyrect scr
                       noscrollcopyrect noscr fixscreen noxrecord xrecord
                       reset_record pointer_mode pm input_skip input
                       client_input speeds debug_pointer dp nodebug_pointer
                       nodp debug_keyboard dk nodebug_keyboard nodk deferupdate
                       defer wait_ui wait_bog nowait_bog wait readtimeout
                       nap nonap sb screen_blank fs gaps grow fuzz snapfb
                       nosnapfb rawfb progressive rfbport http nohttp httpport
                       httpdir enablehttpproxy noenablehttpproxy alwaysshared
                       noalwaysshared nevershared noalwaysshared dontdisconnect
                       nodontdisconnect desktop debug_xevents nodebug_xevents
                       debug_xevents debug_xdamage nodebug_xdamage
                       debug_xdamage debug_wireframe nodebug_wireframe
                       debug_wireframe debug_scroll nodebug_scroll debug_scroll
                       debug_tiles dbt nodebug_tiles nodbt debug_tiles dbg
                       nodbg noremote

                       aro=  display vncdisplay desktopname guess_desktop
                       http_url auth users rootshift clipshift scale_str
                       scaled_x scaled_y scale_numer scale_denom
                       scale_fac scaling_blend scaling_nomult4 scaling_pad
                       scaling_interpolate inetd privremote unsafe safer nocmds
                       passwdfile using_shm logfile o flag rc norc h help V
                       version lastmod bg sigpipe threads readrate netrate
                       netlatency pipeinput clients client_count pid ext_xtest
                       ext_xtrap ext_xrecord ext_xkb ext_xshm ext_xinerama
                       ext_overlay ext_xfixes ext_xdamage ext_xrandr rootwin
                       num_buttons button_mask mouse_x mouse_y bpp depth
                       indexed_color dpy_x dpy_y wdpy_x wdpy_y off_x off_y
                       cdpy_x cdpy_y coff_x coff_y rfbauth passwd

-sync                  By default -remote commands are run asynchronously, that
                       is, the request is posted and the program immediately
                       exits.  Use -sync to have the program wait for an
                       acknowledgement from the x11vnc server that command was
                       processed (somehow).  On the other hand -query requests
                       are always processed synchronously because they have
                       to wait for the result.

                       Also note that if both -remote and -query requests are
                       supplied on the command line, the -remote is processed
                       first (synchronously: no need for -sync), and then
                       the -query request is processed in the normal way.
                       This allows for a reliable way to see if the -remote
                       command was processed by querying for any new settings.
                       Note however that there is timeout of a few seconds so
                       if the x11vnc takes longer than that to process the
                       requests the requestor will think that a failure has
                       taken place.

-noremote              Do not process any remote control commands or queries.
-yesremote             Do process remote control commands or queries.
                       Default: -yesremote

                       A note about security wrt remote control commands.
                       If someone can connect to the X display and change
                       the property VNC_CONNECT, then they can remotely
                       control x11vnc.  Normally access to the X display is
                       protected.  Note that if they can modify VNC_CONNECT
                       on the X server, they have enough permissions to also
                       run their own x11vnc and thus have complete control
                       of the desktop.  If the  "-connect /path/to/file"
                       channel is being used, obviously anyone who can write
                       to /path/to/file can remotely control x11vnc.  So be
                       sure to protect the X display and that file's write
                       permissions.  See -privremote below.

                       If you are paranoid and do not think -noremote is
                       enough, to disable the VNC_CONNECT property channel
                       completely use -novncconnect, or use the -safer
                       option that shuts many things off.

-unsafe                A few remote commands are disabled by default
                       (currently: id:pick, accept:<cmd>, gone:<cmd>, and
                       rawfb:setup:<cmd>) because they are associated with
                       running external programs.  If you specify -unsafe, then
                       these remote-control commands are allowed.  Note that
                       you can still specify these parameters on the command
                       line, they just cannot be changed via remote-control.
-safer                 Equivalent to: -novncconnect -noremote and prohibiting
                       -gui and the -connect file. Shuts off communcation
                       channels.
-privremote            Perform some sanity checks and disable remote-control
                       commands if it appears that the X DISPLAY and/or
                       connectfile can be accessed by other users.  Once
                       remote-control is disabled it cannot be turned back on.
-nocmds                No external commands (e.g. system(3), popen(3), exec(3))
                       will be run.

-deny_all              For use with -remote nodeny: start out denying all
                       incoming clients until "-remote nodeny" is used to
                       let them in.


These options are passed to libvncserver:

-rfbport port          TCP port for RFB protocol
-rfbwait time          max time in ms to wait for RFB client
-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
-passwd plain-password use authentication
                       (use plain-password as password, USE AT YOUR RISK)
-deferupdate time      time in ms to defer updates (default 40)
-desktop name          VNC desktop name (default "LibVNCServer")
-alwaysshared          always treat new clients as shared
-nevershared           never treat new clients as shared
-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
-httpdir dir-path      enable http server using dir-path home
-httpport portnum      use portnum for http connection
-enablehttpproxy       enable http proxy support
-progressive height    enable progressive updating for slow links
-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.

   Pretty wild huh? [1]Contact me if you have any questions or problems.

   Personally, I use:
x11vnc -rfbauth $HOME/.vnc/passwd -flashcmap -cursor X -solid

   (the -flashcmap only matters on old 8-bit X displays)

References

   1. mailto:xvml@karlrunge.com
